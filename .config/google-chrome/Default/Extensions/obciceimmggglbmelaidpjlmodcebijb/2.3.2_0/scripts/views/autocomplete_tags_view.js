// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Views.AutocompleteTagsView = (function(_super) {

    __extends(AutocompleteTagsView, _super);

    function AutocompleteTagsView() {
      return AutocompleteTagsView.__super__.constructor.apply(this, arguments);
    }

    AutocompleteTagsView.include(BH.Modules.I18n);

    AutocompleteTagsView.prototype.template = BH.Templates['autocomplete_tags'];

    AutocompleteTagsView.prototype.events = {
      'click .delete': 'deleteTagClicked',
      'click .tag': 'tagClicked',
      'keyup input.new_tag': 'newTagChanged'
    };

    AutocompleteTagsView.prototype.initialize = function() {
      this.chromeAPI = chrome;
      this.tracker = this.options.tracker;
      this.collection.on('reset', this.render, this);
      this.model.on('change:tags', this.renderActiveTags, this);
      return tagState.on('change:syncing', this.onSyncingChanged, this);
    };

    AutocompleteTagsView.prototype.render = function() {
      var html, properties;
      properties = _.extend(this.getI18nValues(), {
        tags: this.model.tags()
      });
      html = Mustache.to_html(this.template, properties);
      this.$el.html(html);
      this.renderSuggestionsView();
      this.renderActiveTags();
      setTimeout(function() {
        return this.$('input.new_tag').focus();
      }, 0);
      return this;
    };

    AutocompleteTagsView.prototype.renderSuggestionsView = function() {
      var _this = this;
      this.suggestionsView = new BH.Views.SuggestionsView({
        collection: new Backbone.Collection(this.collection.toJSON()),
        disqualifiedTags: this.model.tags()
      });
      $('.suggestions').html(this.suggestionsView.render().el);
      return this.suggestionsView.on('click:tag', function(tag) {
        return _this.attemptToAddTag(tag);
      }, this);
    };

    AutocompleteTagsView.prototype.renderActiveTags = function() {
      var activeTagsView;
      activeTagsView = new BH.Views.ActiveTagsView({
        model: this.model,
        editable: true,
        tracker: this.tracker
      });
      return this.$('.active_tags').html(activeTagsView.render().el);
    };

    AutocompleteTagsView.prototype.newTagChanged = function(ev) {
      var $input, $tag, $tags, enteredTag, tag;
      ev.preventDefault();
      this.previousEnteredTag || (this.previousEnteredTag = '');
      $input = $(ev.currentTarget);
      enteredTag = $input.val();
      if (ev.keyCode === 8 && enteredTag.length === 0 && this.previousEnteredTag.length === 0) {
        $tags = $('ul.tags');
        if ($tags.length > 0) {
          $tag = $tags.find('li:not(.input)').last();
          if ($tag) {
            tag = $tag.find('a.tag').data('tag');
            this.model.removeTag(tag);
            this.tracker.siteUntagged();
            this.suggestionsView.requalifyTag(tag);
            return $tag.remove();
          }
        }
      } else {
        if (enteredTag.length <= 1) {
          return this.suggestionsView.hide();
        } else {
          this.suggestionsView.show();
          if (ev.keyCode === 40) {
            this.suggestionsView.moveDown();
            $input.val(this.suggestionsView.selectedTag());
            return this.previousEnteredTag = enteredTag;
          } else if (ev.keyCode === 38) {
            this.suggestionsView.moveUp();
            $input.val(this.suggestionsView.selectedTag());
            return this.previousEnteredTag = enteredTag;
          } else if (ev.keyCode === 13) {
            tag = this.suggestionsView.selectedTag() || enteredTag;
            return this.attemptToAddTag(tag);
          } else {
            this.suggestionsView.filterBy(enteredTag);
            this.previousEnteredTag = enteredTag;
            return this.$('.new_tag').removeClass('error');
          }
        }
      }
    };

    AutocompleteTagsView.prototype.onSyncingChanged = function() {
      if (tagState.get('syncing') === true) {
        return $('body').addClass('syncing');
      } else {
        return $('body').removeClass('syncing');
      }
    };

    AutocompleteTagsView.prototype.attemptToAddTag = function(tag) {
      var _this = this;
      return this.model.addTag(tag, function(result, operations) {
        var $usedTag;
        if (operations == null) {
          operations = {};
        }
        if (result) {
          _this.suggestionsView.disqualifyTag(tag);
          _this.tracker.siteTagged();
          if (operations.tagCreated) {
            _this.tracker.tagAdded();
          }
        } else {
          $usedTag = _this.$(".active_tags [data-tag='" + tag + "']");
          if ($usedTag.length > 0) {
            $usedTag.addClass('glow');
            setTimeout((function() {
              return $usedTag.removeClass('glow');
            }), 1000);
          } else {
            _this.$('.new_tag').addClass('error');
          }
        }
        if (!_this.$('.new_tag').hasClass('error')) {
          _this.$('.new_tag').val('');
          _this.previousEnteredTag = '';
        }
        return _this.suggestionsView.hide();
      });
    };

    AutocompleteTagsView.prototype.getI18nValues = function() {
      return this.t(['add_a_tag_placeholder']);
    };

    return AutocompleteTagsView;

  })(Backbone.View);

}).call(this);
