// Generated by CoffeeScript 1.6.1
(function() {

  this.BH = {
    Views: {},
    Models: {},
    Collections: {},
    Lib: {
      ContextMenus: {}
    },
    Modules: {},
    Templates: {},
    Trackers: {},
    Presenters: {},
    Persistence: {},
    Migrations: {},
    Init: {},
    Base: function() {}
  };

  if (typeof onServer !== "undefined" && onServer !== null) {
    module.exports = this.BH;
  }

}).call(this);



!function(){!function(window,undefined){var TraceKit={};var _oldTraceKit=window.TraceKit;var _slice=[].slice;var UNKNOWN_FUNCTION="?";function _has(object,key){return Object.prototype.hasOwnProperty.call(object,key)}function _isUndefined(what){return typeof what==="undefined"}TraceKit.noConflict=function noConflict(){window.TraceKit=_oldTraceKit;return TraceKit};TraceKit.wrap=function traceKitWrapper(func){function wrapped(){try{return func.apply(this,arguments)}catch(e){TraceKit.report(e);throw e}}return wrapped};TraceKit.report=function reportModuleWrapper(){var handlers=[],lastException=null,lastExceptionStack=null;function subscribe(handler){installGlobalHandler();handlers.push(handler)}function unsubscribe(handler){for(var i=handlers.length-1;i>=0;--i){if(handlers[i]===handler){handlers.splice(i,1)}}}function notifyHandlers(stack,windowError){var exception=null;if(windowError&&!TraceKit.collectWindowErrors){return}for(var i in handlers){if(_has(handlers,i)){try{handlers[i].apply(null,[stack].concat(_slice.call(arguments,2)))}catch(inner){exception=inner}}}if(exception){throw exception}}var _oldOnerrorHandler,_onErrorHandlerInstalled;function traceKitWindowOnError(message,url,lineNo){var stack=null;if(lastExceptionStack){TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack,url,lineNo,message);stack=lastExceptionStack;lastExceptionStack=null;lastException=null}else{var location={url:url,line:lineNo};location.func=TraceKit.computeStackTrace.guessFunctionName(location.url,location.line);location.context=TraceKit.computeStackTrace.gatherContext(location.url,location.line);stack={mode:"onerror",message:message,url:document.location.href,stack:[location],useragent:navigator.userAgent}}notifyHandlers(stack,"from window.onerror");if(_oldOnerrorHandler){return _oldOnerrorHandler.apply(this,arguments)}return false}function installGlobalHandler(){if(_onErrorHandlerInstalled===true){return}_oldOnerrorHandler=window.onerror;window.onerror=traceKitWindowOnError;_onErrorHandlerInstalled=true}function report(ex){var args=_slice.call(arguments,1);if(lastExceptionStack){if(lastException===ex){return}else{var s=lastExceptionStack;lastExceptionStack=null;lastException=null;notifyHandlers.apply(null,[s,null].concat(args))}}var stack=TraceKit.computeStackTrace(ex);lastExceptionStack=stack;lastException=ex;window.setTimeout(function(){if(lastException===ex){lastExceptionStack=null;lastException=null;notifyHandlers.apply(null,[stack,null].concat(args))}},stack.incomplete?2e3:0);throw ex}report.subscribe=subscribe;report.unsubscribe=unsubscribe;return report}();TraceKit.computeStackTrace=function computeStackTraceWrapper(){var debug=false,sourceCache={};function loadSource(url){if(!TraceKit.remoteFetching){return""}try{function getXHR(){try{return new window.XMLHttpRequest}catch(e){return new window.ActiveXObject("Microsoft.XMLHTTP")}}var request=getXHR();request.open("GET",url,false);request.send("");return request.responseText}catch(e){return""}}function getSource(url){if(!_has(sourceCache,url)){var source="";if(url.indexOf(document.domain)!==-1){source=loadSource(url)}sourceCache[url]=source?source.split("\n"):[]}return sourceCache[url]}function guessFunctionName(url,lineNo){var reFunctionArgNames=/function ([^(]*)\(([^)]*)\)/,reGuessFunction=/['"]?([0-9A-Za-z$_]+)['"]?\s*[:=]\s*(function|eval|new Function)/,line="",maxLines=10,source=getSource(url),m;if(!source.length){return UNKNOWN_FUNCTION}for(var i=0;i<maxLines;++i){line=source[lineNo-i]+line;if(!_isUndefined(line)){if(m=reGuessFunction.exec(line)){return m[1]}else if(m=reFunctionArgNames.exec(line)){return m[1]}}}return UNKNOWN_FUNCTION}function gatherContext(url,line){var source=getSource(url);if(!source.length){return null}var context=[],linesBefore=Math.floor(TraceKit.linesOfContext/2),linesAfter=linesBefore+TraceKit.linesOfContext%2,start=Math.max(0,line-linesBefore-1),end=Math.min(source.length,line+linesAfter-1);line-=1;for(var i=start;i<end;++i){if(!_isUndefined(source[i])){context.push(source[i])}}return context.length>0?context:null}function escapeRegExp(text){return text.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g,"\\$&")}function escapeCodeAsRegExpForMatchingInsideHTML(body){return escapeRegExp(body).replace("<","(?:<|&lt;)").replace(">","(?:>|&gt;)").replace("&","(?:&|&amp;)").replace('"','(?:"|&quot;)').replace(/\s+/g,"\\s+")}function findSourceInUrls(re,urls){var source,m;for(var i=0,j=urls.length;i<j;++i){if((source=getSource(urls[i])).length){source=source.join("\n");if(m=re.exec(source)){return{url:urls[i],line:source.substring(0,m.index).split("\n").length,column:m.index-source.lastIndexOf("\n",m.index)-1}}}}return null}function findSourceInLine(fragment,url,line){var source=getSource(url),re=new RegExp("\\b"+escapeRegExp(fragment)+"\\b"),m;line-=1;if(source&&source.length>line&&(m=re.exec(source[line]))){return m.index}return null}function findSourceByFunctionBody(func){var urls=[window.location.href],scripts=document.getElementsByTagName("script"),body,code=""+func,codeRE=/^function(?:\s+([\w$]+))?\s*\(([\w\s,]*)\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,eventRE=/^function on([\w$]+)\s*\(event\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,re,parts,result;for(var i=0;i<scripts.length;++i){var script=scripts[i];if(script.src){urls.push(script.src)}}if(!(parts=codeRE.exec(code))){re=new RegExp(escapeRegExp(code).replace(/\s+/g,"\\s+"))}else{var name=parts[1]?"\\s+"+parts[1]:"",args=parts[2].split(",").join("\\s*,\\s*");body=escapeRegExp(parts[3]).replace(/;$/,";?");re=new RegExp("function"+name+"\\s*\\(\\s*"+args+"\\s*\\)\\s*{\\s*"+body+"\\s*}")}if(result=findSourceInUrls(re,urls)){return result}if(parts=eventRE.exec(code)){var event=parts[1];body=escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);re=new RegExp("on"+event+"=[\\'\"]\\s*"+body+"\\s*[\\'\"]","i");if(result=findSourceInUrls(re,urls[0])){return result}re=new RegExp(body);if(result=findSourceInUrls(re,urls)){return result}}return null}function computeStackTraceFromStackProp(ex){if(!ex.stack){return null}var chrome=/^\s*at (?:((?:\[object object\])?\S+(?: \[as \S+\])?) )?\(?((?:file|http|https):.*?):(\d+)(?::(\d+))?\)?\s*$/i,gecko=/^\s*(\S*)(?:\((.*?)\))?@((?:file|http|https).*?):(\d+)(?::(\d+))?\s*$/i,lines=ex.stack.split("\n"),stack=[],parts,element,reference=/^(.*) is undefined$/.exec(ex.message);for(var i=0,j=lines.length;i<j;++i){if(parts=gecko.exec(lines[i])){element={url:parts[3],func:parts[1]||UNKNOWN_FUNCTION,args:parts[2]?parts[2].split(","):"",line:+parts[4],column:parts[5]?+parts[5]:null}}else if(parts=chrome.exec(lines[i])){element={url:parts[2],func:parts[1]||UNKNOWN_FUNCTION,line:+parts[3],column:parts[4]?+parts[4]:null}}else{continue}if(!element.func&&element.line){element.func=guessFunctionName(element.url,element.line)}if(element.line){element.context=gatherContext(element.url,element.line)}stack.push(element)}if(stack[0]&&stack[0].line&&!stack[0].column&&reference){stack[0].column=findSourceInLine(reference[1],stack[0].url,stack[0].line)}if(!stack.length){return null}return{mode:"stack",name:ex.name,message:ex.message,url:document.location.href,stack:stack,useragent:navigator.userAgent}}function computeStackTraceFromStacktraceProp(ex){var stacktrace=ex.stacktrace;var testRE=/ line (\d+), column (\d+) in (?:<anonymous function: ([^>]+)>|([^\)]+))\((.*)\) in (.*):\s*$/i,lines=stacktrace.split("\n"),stack=[],parts;for(var i=0,j=lines.length;i<j;i+=2){if(parts=testRE.exec(lines[i])){var element={line:+parts[1],column:+parts[2],func:parts[3]||parts[4],args:parts[5]?parts[5].split(","):[],url:parts[6]};if(!element.func&&element.line){element.func=guessFunctionName(element.url,element.line)}if(element.line){try{element.context=gatherContext(element.url,element.line)}catch(exc){}}if(!element.context){element.context=[lines[i+1]]}stack.push(element)}}if(!stack.length){return null}return{mode:"stacktrace",name:ex.name,message:ex.message,url:document.location.href,stack:stack,useragent:navigator.userAgent}}function computeStackTraceFromOperaMultiLineMessage(ex){var lines=ex.message.split("\n");if(lines.length<4){return null}var lineRE1=/^\s*Line (\d+) of linked script ((?:file|http|https)\S+)(?:: in function (\S+))?\s*$/i,lineRE2=/^\s*Line (\d+) of inline#(\d+) script in ((?:file|http|https)\S+)(?:: in function (\S+))?\s*$/i,lineRE3=/^\s*Line (\d+) of function script\s*$/i,stack=[],scripts=document.getElementsByTagName("script"),inlineScriptBlocks=[],parts,i,len,source;for(i in scripts){if(_has(scripts,i)&&!scripts[i].src){inlineScriptBlocks.push(scripts[i])}}for(i=2,len=lines.length;i<len;i+=2){var item=null;if(parts=lineRE1.exec(lines[i])){item={url:parts[2],func:parts[3],line:+parts[1]}}else if(parts=lineRE2.exec(lines[i])){item={url:parts[3],func:parts[4]};var relativeLine=+parts[1];var script=inlineScriptBlocks[parts[2]-1];if(script){source=getSource(item.url);if(source){source=source.join("\n");var pos=source.indexOf(script.innerText);if(pos>=0){item.line=relativeLine+source.substring(0,pos).split("\n").length}}}}else if(parts=lineRE3.exec(lines[i])){var url=window.location.href.replace(/#.*$/,""),line=parts[1];var re=new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[i+1]));source=findSourceInUrls(re,[url]);item={url:url,line:source?source.line:line,func:""}}if(item){if(!item.func){item.func=guessFunctionName(item.url,item.line)}var context=gatherContext(item.url,item.line);var midline=context?context[Math.floor(context.length/2)]:null;if(context&&midline.replace(/^\s*/,"")===lines[i+1].replace(/^\s*/,"")){item.context=context}else{item.context=[lines[i+1]]}stack.push(item)}}if(!stack.length){return null}return{mode:"multiline",name:ex.name,message:lines[0],url:document.location.href,stack:stack,useragent:navigator.userAgent}}function augmentStackTraceWithInitialElement(stackInfo,url,lineNo,message){var initial={url:url,line:lineNo};if(initial.url&&initial.line){stackInfo.incomplete=false;if(!initial.func){initial.func=guessFunctionName(initial.url,initial.line)}if(!initial.context){initial.context=gatherContext(initial.url,initial.line)}var reference=/ '([^']+)' /.exec(message);if(reference){initial.column=findSourceInLine(reference[1],initial.url,initial.line)}if(stackInfo.stack.length>0){if(stackInfo.stack[0].url===initial.url){if(stackInfo.stack[0].line===initial.line){return false}else if(!stackInfo.stack[0].line&&stackInfo.stack[0].func===initial.func){stackInfo.stack[0].line=initial.line;stackInfo.stack[0].context=initial.context;return false}}}stackInfo.stack.unshift(initial);stackInfo.partial=true;return true}else{stackInfo.incomplete=true}return false}function computeStackTraceByWalkingCallerChain(ex,depth){var functionName=/function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,stack=[],funcs={},recursion=false,parts,item,source;for(var curr=computeStackTraceByWalkingCallerChain.caller;curr&&!recursion;curr=curr.caller){if(curr===computeStackTrace||curr===TraceKit.report){continue}item={url:null,func:UNKNOWN_FUNCTION,line:null,column:null};if(curr.name){item.func=curr.name}else if(parts=functionName.exec(curr.toString())){item.func=parts[1]}if(source=findSourceByFunctionBody(curr)){item.url=source.url;item.line=source.line;if(item.func===UNKNOWN_FUNCTION){item.func=guessFunctionName(item.url,item.line)}var reference=/ '([^']+)' /.exec(ex.message||ex.description);if(reference){item.column=findSourceInLine(reference[1],source.url,source.line)}}if(funcs[""+curr]){recursion=true}else{funcs[""+curr]=true}stack.push(item)}if(depth){stack.splice(0,depth)}var result={mode:"callers",name:ex.name,message:ex.message,url:document.location.href,stack:stack,useragent:navigator.userAgent};augmentStackTraceWithInitialElement(result,ex.sourceURL||ex.fileName,ex.line||ex.lineNumber,ex.message||ex.description);return result}function computeStackTrace(ex,depth){var stack=null;depth=depth==null?0:+depth;try{stack=computeStackTraceFromStacktraceProp(ex);if(stack){return stack}}catch(e){if(debug){throw e}}try{stack=computeStackTraceFromStackProp(ex);if(stack){return stack}}catch(e){if(debug){throw e}}try{stack=computeStackTraceFromOperaMultiLineMessage(ex);if(stack){return stack}}catch(e){if(debug){throw e}}try{stack=computeStackTraceByWalkingCallerChain(ex,depth+1);if(stack){return stack}}catch(e){if(debug){throw e}}return{mode:"failed"}}function computeStackTraceOfCaller(depth){depth=(depth==null?0:+depth)+1;try{throw new Error}catch(ex){return computeStackTrace(ex,depth+1)}return null}computeStackTrace.augmentStackTraceWithInitialElement=augmentStackTraceWithInitialElement;computeStackTrace.guessFunctionName=guessFunctionName;computeStackTrace.gatherContext=gatherContext;computeStackTrace.ofCaller=computeStackTraceOfCaller;return computeStackTrace}();!function extendToAsynchronousCallbacks(){var _helper=function _helper(fnName){var originalFn=window[fnName];window[fnName]=function traceKitAsyncExtension(){var args=_slice.call(arguments);var originalCallback=args[0];if(typeof originalCallback==="function"){args[0]=TraceKit.wrap(originalCallback)}if(originalFn.apply){return originalFn.apply(this,args)}else{return originalFn(args[0],args[1])}}};_helper("setTimeout");_helper("setInterval")}();if(!TraceKit.remoteFetching){TraceKit.remoteFetching=true}if(!TraceKit.collectWindowErrors){TraceKit.collectWindowErrors=true}if(!TraceKit.linesOfContext||TraceKit.linesOfContext<1){TraceKit.linesOfContext=11}window.TraceKit=TraceKit}(window);var Notice;Notice=function(){function Notice(options){var k,v,_ref,_ref1,_ref2,_ref3,_ref4;this.options=options!=null?options:{};this.stackInfo=this.options.stackInfo||this.options.error&&TraceKit.computeStackTrace(this.options.error);this.trace=this._parseBacktrace((_ref=this.stackInfo)!=null?_ref.stack:void 0);this["class"]=(_ref1=this.stackInfo)!=null?_ref1.name:void 0;this.message=(_ref2=this.stackInfo)!=null?_ref2.message:void 0;this.source=this.stackInfo&&this._extractSource(this.stackInfo.stack);this.url=document.URL;this.project_root=Honeybadger.configuration.project_root;this.environment=Honeybadger.configuration.environment;this.component=Honeybadger.configuration.component;this.action=Honeybadger.configuration.action;this.context={};_ref3=Honeybadger.context;for(k in _ref3){v=_ref3[k];this.context[k]=v}if(this.options.context){_ref4=this.options.context;for(k in _ref4){v=_ref4[k];this.context[k]=v}}}Notice.prototype.toJSON=function(){return JSON.stringify({notifier:{name:"honeybadger.js",url:"https://github.com/honeybadger-io/honeybadger-js",version:Honeybadger.version,language:"javascript"},error:{"class":this["class"],message:this.message,backtrace:this.trace,source:this.source},request:{url:this.url,component:this.component,action:this.action,context:this.context,cgi_data:this._cgiData()},server:{project_root:this.project_root,environment_name:this.environment}})};Notice.prototype._parseBacktrace=function(stack){var backtrace,trace,_i,_len,_ref,_ref1;if(stack==null){stack=[]}backtrace=[];for(_i=0,_len=stack.length;_i<_len;_i++){trace=stack[_i];if((_ref=trace.url)!=null?_ref.match(/honeybadger(?:\.min)?\.js/):void 0){continue}backtrace.push({file:((_ref1=trace.url)!=null?_ref1.replace(Honeybadger.configuration.project_root,"[PROJECT_ROOT]"):void 0)||"unknown",number:trace.line,method:trace.func})}return backtrace};Notice.prototype._extractSource=function(stack){var i,line,source,_i,_len,_ref,_ref1,_ref2;if(stack==null){stack=[]}source={};_ref2=(_ref=(_ref1=stack[0])!=null?_ref1.context:void 0)!=null?_ref:[];for(i=_i=0,_len=_ref2.length;_i<_len;i=++_i){line=_ref2[i];source[i]=line}return source};Notice.prototype._cgiData=function(){var data,k,v;data={};for(k in navigator){v=navigator[k];if(typeof v!=="object"){data[k.split(/(?=[A-Z][a-z]*)/).join("_").toUpperCase()]=v}}data["HTTP_USER_AGENT"]=data["USER_AGENT"];delete data["USER_AGENT"];if(document.referrer.match(/\S/)){data["HTTP_REFERER"]=document.referrer}return data};return Notice}();var Honeybadger;Honeybadger=function(){var _this=this;function Honeybadger(){}Honeybadger.version="0.0.2";Honeybadger.default_configuration={api_key:null,host:"api.honeybadger.io",ssl:true,project_root:window.location.protocol+"//"+window.location.host,environment:"production",component:null,action:null,disabled:true,onerror:false};Honeybadger.configured=false;Honeybadger.configure=function(options){var k,v;if(options==null){options={}}if(this.configured===false){if(typeof options.disabled==="undefined"){options["disabled"]=false}this.configured=true}for(k in options){v=options[k];this.configuration[k]=v}TraceKit.collectWindowErrors=this.configuration.onerror;return this};Honeybadger.configuration={reset:function(){var k,v,_ref;Honeybadger.configured=false;_ref=Honeybadger.default_configuration;for(k in _ref){v=_ref[k];Honeybadger.configuration[k]=v}TraceKit.collectWindowErrors=Honeybadger.configuration.onerror;return Honeybadger}};Honeybadger.configuration.reset();Honeybadger.context={};Honeybadger.resetContext=function(options){if(options==null){options={}}this.context=options;return this};Honeybadger.setContext=function(options){var k,v;if(options==null){options={}}for(k in options){v=options[k];this.context[k]=v}return this};Honeybadger.notify=function(error,options){var notice;if(options==null){options={}}if(this.configuration.disabled===true){return false}if(error){options["error"]=error}notice=new Notice(options);return this._sendRequest(notice.toJSON())};Honeybadger._sendRequest=function(data){var url;url="http"+(this.configuration.ssl&&"s"||"")+"://"+this.configuration.host+"/v1/notices.html";return this._crossDomainPost(url,data)};Honeybadger._crossDomainPost=function(url,payload){var form,iframe,input,uniqueNameOfFrame;iframe=document.createElement("iframe");uniqueNameOfFrame="_hb_"+(new Date).getTime();document.body.appendChild(iframe);iframe.style.display="none";iframe.contentWindow.name=uniqueNameOfFrame;form=document.createElement("form");form.target=uniqueNameOfFrame;form.action=url;form.method="POST";input=document.createElement("input");input.type="hidden";input.name="payload";input.value=payload;form.appendChild(input);input=document.createElement("input");input.type="hidden";input.name="api_key";input.value=this.configuration.api_key;form.appendChild(input);document.body.appendChild(form);return form.submit()};Honeybadger._handleTraceKitSubscription=function(stackInfo){return Honeybadger.notify(null,{stackInfo:stackInfo})};return Honeybadger}.call(this);TraceKit.report.subscribe(Honeybadger._handleTraceKitSubscription);(typeof exports!=="undefined"&&exports!==null?exports:this).Honeybadger=Honeybadger}.call(this);



//     Underscore.js 1.4.3
//     http://underscorejs.org
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // with specific `key:value` pairs.
  _.where = function(obj, attrs) {
    if (_.isEmpty(attrs)) return [];
    return _.filter(obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function(func, context) {
    var args, bound;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + (0 | Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = '' + ++idCounter;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);



// From http://arcturo.github.com/library/coffeescript/03_classes.html

var moduleKeywords,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

moduleKeywords = ['extended', 'included'];

Module = (function() {

  function Module() {}

  Module.extend = function(obj) {
    var key, value, _ref;
    for (key in obj) {
      value = obj[key];
      if (__indexOf.call(moduleKeywords, key) < 0) {
        this[key] = value;
      }
    }
    if ((_ref = obj.extended) != null) {
      _ref.apply(this);
    }
    return this;
  };

  Module.include = function(obj) {
    var key, value, _ref;
    for (key in obj) {
      value = obj[key];
      if (__indexOf.call(moduleKeywords, key) < 0) {
        this.prototype[key] = value;
      }
    }
    if ((_ref = obj.included) != null) {
      _ref.apply(this);
    }
    return this;
  };

  return Module;

})();

if(typeof(Backbone) != 'undefined') {
  Backbone.Model.include = Backbone.View.include = Backbone.Collection.include = Module.include;
}
BH.Base.include = Module.include;



var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-43186716-1']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = 'https://ssl.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();



/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(e,m){var p={},j=p.lib={},l=function(){},f=j.Base={extend:function(a){l.prototype=this;var c=new l;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
n=j.WordArray=f.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length},toString:function(a){return(a||h).stringify(this)},concat:function(a){var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b<a;b++)c[d+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((d+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[d+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=e.ceil(c/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)}}),b=p.enc={},h=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++){var f=c[d>>>2]>>>24-8*(d%4)&255;b.push((f>>>4).toString(16));b.push((f&15).toString(16))}return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d+=2)b[d>>>3]|=parseInt(a.substr(d,
2),16)<<24-4*(d%8);return new n.init(b,c/2)}},g=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++)b.push(String.fromCharCode(c[d>>>2]>>>24-8*(d%4)&255));return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d++)b[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return new n.init(b,c)}},r=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},
k=j.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new n.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d}return new n.init(g,d)},clone:function(){var a=f.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=k.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,b){return(new a.init(b)).finalize(c)}},_createHmacHelper:function(a){return function(b,f){return(new s.HMAC.init(a,
f)).finalize(b)}}});var s=p.algo={};return p}(Math);
(function(){var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend({_doReset:function(){this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(f,n){for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80>a;a++){if(16>a)l[a]=f[n+a]|0;else{var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c<<1|c>>>31}c=(h<<5|h>>>27)+j+l[a];c=20>a?c+((g&e|~g&k)+1518500249):40>a?c+((g^e^k)+1859775393):60>a?c+((g&e|g&k|e&k)-1894007588):c+((g^e^
k)-899497514);j=k;k=e;e=g<<30|g>>>2;g=h;h=c}b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0},_doFinalize:function(){var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h>>>5]|=128<<24-h%32;e[(h+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(h+64>>>9<<4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=j.clone.call(this);e._hash=this._hash.clone();return e}});e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)})();



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Modules.Worker = {
    worker: function(name, options, callback) {
      var basePath, path, worker;
      basePath = 'scripts/workers';
      path = (function() {
        switch (name) {
          case 'sanitizer':
            return "" + basePath + "/sanitizer.js";
          case 'domainGrouper':
            return "" + basePath + "/domain_grouper.js";
          case 'timeGrouper':
            return "" + basePath + "/time_grouper.js";
          case 'dayGrouper':
            return "" + basePath + "/day_grouper.js";
        }
      })();
      worker = new Worker(path);
      worker.onmessage = function(e) {
        if (e.data.log) {
          return console.log(e.data.log);
        } else {
          callback(e.data);
          return worker.terminate();
        }
      };
      return worker.postMessage(options);
    }
  };

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Modules.I18n = {
    t: function(key, replacements) {
      var keys, lookup, _i, _len;
      if (replacements == null) {
        replacements = [];
      }
      if (key instanceof Array) {
        keys = key;
        lookup = {};
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          lookup["i18n_" + key] = this.chromeAPI.i18n.getMessage(key.toString());
        }
        return lookup;
      } else {
        return this.chromeAPI.i18n.getMessage(key, replacements);
      }
    }
  };

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Modules.Url = {
    urlFor: function(key, id, opts) {
      var base, buildBase, route;
      base = 'chrome://history/';
      if (key == null) {
        return base;
      }
      buildBase = function(opts) {
        if (opts != null ? opts.absolute : void 0) {
          return base;
        } else {
          return '';
        }
      };
      route = (function() {
        switch (key) {
          case 'search':
            return "#search/" + id;
          case 'week':
            return "#weeks/" + id;
          case 'day':
            return "#days/" + id;
          case 'tag':
            return "#tags/" + id;
        }
      })();
      return "" + (buildBase(opts)) + route;
    }
  };

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Trackers.ErrorTracker = (function() {

    ErrorTracker.prototype.key = "eb2245d5729a3c65d7e429f4e7690a62";

    ErrorTracker.prototype.version = "2.3.2";

    ErrorTracker.prototype.environment = "production";

    function ErrorTracker(tracker) {
      this.tracker = tracker;
      this.tracker.setContext({
        version: this.version
      });
      this.tracker.configure({
        api_key: this.key,
        environment: this.environment,
        onerror: true
      });
    }

    ErrorTracker.prototype.report = function(e, data) {
      if (data == null) {
        data = {};
      }
      return this.tracker.notify(e, {
        context: data
      });
    };

    return ErrorTracker;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Trackers.AnalyticsTracker = (function() {

    function AnalyticsTracker() {
      if (typeof _gaq === "undefined" || _gaq === null) {
        throw "Analytics not set";
      }
    }

    AnalyticsTracker.prototype.trackEvent = function(params) {
      params.unshift('_trackEvent');
      return this.track(params);
    };

    AnalyticsTracker.prototype.pageView = function(url) {
      if (url.match(/search/)) {
        url = 'search';
      }
      return this.track(['_trackPageview', "/" + url]);
    };

    AnalyticsTracker.prototype.track = function(params) {
      return _gaq.push(params);
    };

    AnalyticsTracker.prototype.historyOpen = function() {
      return this.trackEvent(['History', 'Open']);
    };

    AnalyticsTracker.prototype.weekView = function(date, distanceFromCurrentWeek) {
      return this.trackEvent(['Weeks', 'Click', date, distanceFromCurrentWeek]);
    };

    AnalyticsTracker.prototype.visitDeletion = function() {
      return this.trackEvent(['Visit', 'Delete']);
    };

    AnalyticsTracker.prototype.groupedVisitsDeletion = function() {
      return this.trackEvent(['Grouped visits', 'Delete']);
    };

    AnalyticsTracker.prototype.timeIntervalDeletion = function() {
      return this.trackEvent(['Time interval', 'Delete']);
    };

    AnalyticsTracker.prototype.dayVisitsDeletion = function() {
      return this.trackEvent(['Day visits', 'Delete']);
    };

    AnalyticsTracker.prototype.weekVisitsDeletion = function() {
      return this.trackEvent(['Week visits', 'Delete']);
    };

    AnalyticsTracker.prototype.searchResultsDeletion = function() {
      return this.trackEvent(['Search results', 'Delete']);
    };

    AnalyticsTracker.prototype.paginationClick = function() {
      return this.trackEvent(['Pagination', 'Click']);
    };

    AnalyticsTracker.prototype.omniboxSearch = function() {
      return this.trackEvent(['Omnibox', 'Search']);
    };

    AnalyticsTracker.prototype.contextMenuClick = function() {
      return this.trackEvent(['Context menu', 'Click']);
    };

    AnalyticsTracker.prototype.selectionContextMenuClick = function() {
      return this.trackEvent(['Selection context menu', 'Click']);
    };

    AnalyticsTracker.prototype.syncStorageError = function(operation, msg) {
      return this.trackEvent(['Storage Error', operation, 'Sync', msg]);
    };

    AnalyticsTracker.prototype.syncStorageAccess = function(operation) {
      return this.trackEvent(['Storage Access', operation, 'Sync']);
    };

    AnalyticsTracker.prototype.localStorageError = function(operation, msg) {
      return this.trackEvent(['Storage Error', operation, 'Local', msg]);
    };

    AnalyticsTracker.prototype.mailingListPrompt = function() {
      return this.trackEvent(['Mailing List Prompt', 'Seen']);
    };

    AnalyticsTracker.prototype.popupVisible = function() {
      return this.trackEvent(['Popup', 'Seen']);
    };

    AnalyticsTracker.prototype.exploreTagsPopupClick = function() {
      return this.trackEvent(['Popup', 'Explore Tags Click']);
    };

    AnalyticsTracker.prototype.searchByDomainPopupClick = function() {
      return this.trackEvent(['Popup', 'Search by Domain Click']);
    };

    AnalyticsTracker.prototype.tagDetailsPopupClick = function() {
      return this.trackEvent(['Popup', 'Tag Details Click']);
    };

    AnalyticsTracker.prototype.viewAllHistoryPopupClick = function() {
      return this.trackEvent(['Popup', 'View all History Click']);
    };

    AnalyticsTracker.prototype.howToTagClick = function() {
      return this.trackEvent(['Tags', 'How to Tag Click']);
    };

    AnalyticsTracker.prototype.deleteAllTagsClick = function() {
      return this.trackEvent(['Tags', 'Delete all Click']);
    };

    AnalyticsTracker.prototype.siteTagDrag = function() {
      return this.trackEvent(['Tag', 'Site Drag']);
    };

    AnalyticsTracker.prototype.siteTagDrop = function() {
      return this.trackEvent(['Tag', 'Site Drop']);
    };

    AnalyticsTracker.prototype.renameTagClick = function() {
      return this.trackEvent(['Tag', 'Rename Click']);
    };

    AnalyticsTracker.prototype.deleteTagClick = function() {
      return this.trackEvent(['Tag', 'Delete Tag Click']);
    };

    AnalyticsTracker.prototype.tagAdded = function() {
      return this.trackEvent(['Tag', 'Added']);
    };

    AnalyticsTracker.prototype.tagRemoved = function() {
      return this.trackEvent(['Tag', 'Removed']);
    };

    AnalyticsTracker.prototype.tagRenamed = function() {
      return this.trackEvent(['Tag', 'Renamed']);
    };

    AnalyticsTracker.prototype.siteTagged = function() {
      return this.trackEvent(['Site', 'Tagged']);
    };

    AnalyticsTracker.prototype.siteUntagged = function() {
      return this.trackEvent(['Site', 'Untagged']);
    };

    AnalyticsTracker.prototype.shareClicked = function() {
      return this.trackEvent(['Tag', 'Shared']);
    };

    AnalyticsTracker.prototype.getStartedSyncingModalSeen = function() {
      return this.trackEvent(['Get Started Modal', 'Seen']);
    };

    AnalyticsTracker.prototype.getStartedSyncingContinueClicked = function() {
      return this.trackEvent(['Get Started Modal', 'Continue Click']);
    };

    AnalyticsTracker.prototype.getStartedSyncingCancelClicked = function() {
      return this.trackEvent(['Get Started Modal', 'Cancel Click']);
    };

    AnalyticsTracker.prototype.syncPurchaseSuccess = function() {
      return this.trackEvent(['Sync', 'Purchased', 'Success']);
    };

    AnalyticsTracker.prototype.syncPurchaseFailure = function() {
      return this.trackEvent(['Sync', 'Purchased', 'Failure']);
    };

    AnalyticsTracker.prototype.syncDecisionModalSeen = function() {
      return this.trackEvent(['Sync Decision Modal', 'Seen']);
    };

    AnalyticsTracker.prototype.syncAutomaticModalSeen = function() {
      return this.trackEvent(['Sync Automatic Modal', 'Seen']);
    };

    AnalyticsTracker.prototype.userLoggedIn = function() {
      return this.trackEvent(['User', 'Log In']);
    };

    AnalyticsTracker.prototype.userLoggedOut = function() {
      return this.trackEvent(['User', 'Log Out']);
    };

    AnalyticsTracker.prototype.userCreationFailure = function() {
      return this.trackEvent(['User', 'Creation', 'Failure']);
    };

    AnalyticsTracker.prototype.userCreationSuccess = function() {
      return this.trackEvent(['User', 'Creation', 'Success']);
    };

    AnalyticsTracker.prototype.userOAuthFailure = function() {
      return this.trackEvent(['User', 'OAuth', 'Failure']);
    };

    AnalyticsTracker.prototype.userOAuthSuccess = function() {
      return this.trackEvent(['User', 'OAuth', 'Success']);
    };

    AnalyticsTracker.prototype.ensureDatetimeOnTaggedSitesMigration = function() {
      return this.trackEvent(['Migration', 'ensure_datetime_on_tagged_sites']);
    };

    return AnalyticsTracker;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Lib.PageContextMenu = (function(_super) {

    __extends(PageContextMenu, _super);

    PageContextMenu.include(BH.Modules.I18n);

    PageContextMenu.include(BH.Modules.Url);

    function PageContextMenu(options) {
      if (options == null) {
        options = {};
      }
      if (options.chrome == null) {
        throw "Chrome API not set";
      }
      if (options.tracker == null) {
        throw "Tracker not set";
      }
      this.chromeAPI = options.chrome;
      this.tracker = options.tracker;
      this.id = 'better_history_page_context_menu';
    }

    PageContextMenu.prototype.create = function() {
      var _this = this;
      this.menu = this.chromeAPI.contextMenus.create({
        title: this.t('visits_to_domain', ['domain']),
        contexts: ['page'],
        id: this.id
      });
      return this.chromeAPI.contextMenus.onClicked.addListener(function(data) {
        return _this.onClick(data);
      });
    };

    PageContextMenu.prototype.onClick = function(data) {
      var domain, url, urlOptions;
      if (data.menuItemId === this.id) {
        urlOptions = {
          absolute: true
        };
        url = (domain = this.getDomain(data.pageUrl)) ? this.urlFor('search', domain, urlOptions) : "chrome://history/#search";
        this.tracker.contextMenuClick();
        return this.chromeAPI.tabs.create({
          url: url
        });
      }
    };

    PageContextMenu.prototype.updateTitleDomain = function(tab) {
      var domain;
      if (tab == null) {
        tab = {};
      }
      if (domain = this.getDomain(tab.url)) {
        return this.chromeAPI.contextMenus.update(this.menu, {
          title: this.t('visits_to_domain', [domain])
        });
      }
    };

    PageContextMenu.prototype.listenToTabs = function() {
      var _this = this;
      this.chromeAPI.tabs.onActivated.addListener(function(tabInfo) {
        if (_this.menu) {
          return _this.onTabSelectionChanged(tabInfo.tabId);
        }
      });
      return this.chromeAPI.tabs.onUpdated.addListener(function(tabId, changedInfo, tab) {
        if (_this.menu) {
          return _this.onTabUpdated(tab);
        }
      });
    };

    PageContextMenu.prototype.onTabSelectionChanged = function(tabId) {
      var _this = this;
      return this.chromeAPI.tabs.get(tabId, function(tab) {
        return _this.updateTitleDomain(tab);
      });
    };

    PageContextMenu.prototype.onTabUpdated = function(tab) {
      if (tab != null ? tab.selected : void 0) {
        return this.updateTitleDomain(tab);
      }
    };

    PageContextMenu.prototype.remove = function() {
      this.chromeAPI.contextMenus.remove(this.menu);
      return delete this.menu;
    };

    PageContextMenu.prototype.getDomain = function(url) {
      var match;
      if (url == null) {
        url = '';
      }
      match = url.match(/\w+:\/\/(.*?)\//);
      if (match != null) {
        return match[1].replace('www.', '');
      } else {
        return false;
      }
    };

    return PageContextMenu;

  })(BH.Base);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Lib.SelectionContextMenu = (function(_super) {

    __extends(SelectionContextMenu, _super);

    SelectionContextMenu.include(BH.Modules.I18n);

    SelectionContextMenu.include(BH.Modules.Url);

    function SelectionContextMenu(options) {
      if (options == null) {
        options = {};
      }
      if (options.chrome == null) {
        throw "Chrome API not set";
      }
      if (options.tracker == null) {
        throw "Tracker not set";
      }
      this.chromeAPI = options.chrome;
      this.tracker = options.tracker;
      this.id = 'better_history_selection_context_menu';
    }

    SelectionContextMenu.prototype.create = function() {
      var _ref,
        _this = this;
      if (((_ref = this.chromeAPI.contextMenus) != null ? _ref.create : void 0) != null) {
        this.menu = this.chromeAPI.contextMenus.create({
          title: this.t('search_in_history'),
          contexts: ['selection'],
          id: this.id
        });
        return this.chromeAPI.contextMenus.onClicked.addListener(function(data) {
          return _this.onClick(data);
        });
      }
    };

    SelectionContextMenu.prototype.onClick = function(data) {
      var url, urlOptions;
      if (data.menuItemId === this.id) {
        urlOptions = {
          absolute: true
        };
        url = this.urlFor('search', data.selectionText, urlOptions);
        this.tracker.selectionContextMenuClick();
        return this.chromeAPI.tabs.create({
          url: url
        });
      }
    };

    SelectionContextMenu.prototype.remove = function() {
      this.chromeAPI.contextMenus.remove(this.menu);
      return delete this.menu;
    };

    return SelectionContextMenu;

  })(BH.Base);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Lib.Omnibox = (function(_super) {

    __extends(Omnibox, _super);

    Omnibox.include(BH.Modules.Url);

    function Omnibox(options) {
      if (options == null) {
        options = {};
      }
      if (options.chrome == null) {
        throw "Chrome API not set";
      }
      if (options.tracker == null) {
        throw "Tracker not set";
      }
      this.chromeAPI = options.chrome;
      this.tracker = options.tracker;
    }

    Omnibox.prototype.listen = function() {
      var _ref, _ref1,
        _this = this;
      if ((_ref = this.chromeAPI.omnibox) != null) {
        _ref.onInputChanged.addListener(function(text, suggest) {
          return _this.setDefaultSuggestion(text);
        });
      }
      return (_ref1 = this.chromeAPI.omnibox) != null ? _ref1.onInputEntered.addListener(function(text) {
        _this.tracker.omniboxSearch();
        return _this.getActiveTab(function(tabId) {
          return _this.updateTabURL(tabId, text);
        });
      }) : void 0;
    };

    Omnibox.prototype.setDefaultSuggestion = function(text) {
      var _ref;
      return (_ref = this.chromeAPI.omnibox) != null ? _ref.setDefaultSuggestion({
        description: "Search <match>" + text + "</match> in history"
      }) : void 0;
    };

    Omnibox.prototype.getActiveTab = function(callback) {
      return this.chromeAPI.tabs.query({
        active: true,
        currentWindow: true
      }, function(tabs) {
        return callback(tabs[0].id);
      });
    };

    Omnibox.prototype.updateTabURL = function(tabId, text) {
      return this.chromeAPI.tabs.update(tabId, {
        url: this.urlFor('search', text, {
          absolute: true
        })
      });
    };

    return Omnibox;

  })(BH.Base);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Lib.SyncStore = (function() {

    function SyncStore(options) {
      if (options == null) {
        options = {};
      }
      if (options.chrome == null) {
        throw "Chrome API not set";
      }
      if (options.tracker == null) {
        throw "Tracker not set";
      }
      this.chromeAPI = options.chrome;
      this.tracker = options.tracker;
    }

    SyncStore.prototype.set = function(object, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.chromeAPI.storage.sync.set(object, function(data) {
        return _this.wrappedCallback('Set', data, callback);
      });
    };

    SyncStore.prototype.remove = function(key, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.chromeAPI.storage.sync.remove(key, function(data) {
        return _this.wrappedCallback('Remove', data, callback);
      });
    };

    SyncStore.prototype.get = function(key, callback) {
      var _this = this;
      return this.chromeAPI.storage.sync.get(key, function(data) {
        return _this.wrappedCallback('Get', data, callback);
      });
    };

    SyncStore.prototype.wrappedCallback = function(operation, data, callback) {
      var message, _ref;
      if (data == null) {
        data = {};
      }
      if (this.chromeAPI.runtime.lastError != null) {
        message = (_ref = this.chromeAPI.runtime.lastError) != null ? _ref.message : void 0;
        this.tracker.syncStorageError(operation, message);
      } else {
        if (operation !== 'Get') {
          this.tracker.syncStorageAccess(operation);
        }
      }
      return callback(data);
    };

    return SyncStore;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Lib.LocalStore = (function() {

    function LocalStore(options) {
      if (options == null) {
        options = {};
      }
      if (options.chrome == null) {
        throw "Chrome API not set";
      }
      if (options.tracker == null) {
        throw "Tracker not set";
      }
      this.chromeAPI = options.chrome;
      this.tracker = options.tracker;
    }

    LocalStore.prototype.set = function(object, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.chromeAPI.storage.local.set(object, function(data) {
        return _this.wrappedCallback('Set', data, callback);
      });
    };

    LocalStore.prototype.remove = function(key, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.chromeAPI.storage.local.remove(key, function(data) {
        return _this.wrappedCallback('Remove', data, callback);
      });
    };

    LocalStore.prototype.clear = function() {
      return this.chromeAPI.storage.local.clear();
    };

    LocalStore.prototype.get = function(key, callback) {
      var _this = this;
      return this.chromeAPI.storage.local.get(key, function(data) {
        return _this.wrappedCallback('Get', data, callback);
      });
    };

    LocalStore.prototype.wrappedCallback = function(operation, data, callback) {
      var message, _ref;
      if (this.chromeAPI.runtime.lastError != null) {
        message = (_ref = this.chromeAPI.runtime.lastError) != null ? _ref.message : void 0;
        this.tracker.localStorageError(operation, message);
      }
      return callback(data);
    };

    return LocalStore;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var date, datetime, exampleTags;

  BH.Lib.ExampleTags = (function() {

    function ExampleTags() {}

    ExampleTags.prototype.load = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return persistence.tag()["import"](exampleTags, function() {
        if (user.isLoggedIn()) {
          return persistence.tag().fetchTags(function(tags, compiledTags) {
            var translator;
            translator = new BH.Lib.SyncingTranslator();
            return translator.forServer(compiledTags, function(sites) {
              persistence.remote().updateSites(sites);
              chrome.runtime.sendMessage({
                action: 'calculate hash'
              });
              return callback();
            });
          });
        } else {
          return callback();
        }
      });
    };

    return ExampleTags;

  })();

  date = new Date().getTime();

  datetime = function() {
    return date += 1;
  };

  exampleTags = {
    tags: ['games', 'places to travel', 'clothing', 'recipes', 'friends', 'funny videos', 'world news', 'productivity'],
    friends: [
      {
        title: 'Facebook',
        url: 'http://www.facebook.com',
        datetime: datetime()
      }, {
        title: 'Twitter',
        url: 'https://twitter.com',
        datetime: datetime()
      }, {
        title: 'LinkedIn',
        url: 'http://www.linkedin.com',
        datetime: datetime()
      }, {
        title: 'Reddit',
        url: 'http://www.reddit.com',
        datetime: datetime()
      }, {
        title: 'Instagram',
        url: 'http://www.instagram.com',
        datetime: datetime()
      }, {
        title: 'Pinterest',
        url: 'http://www.pinterest.com',
        datetime: datetime()
      }
    ],
    'funny videos': [
      {
        title: '▶ Charlie bit my finger - again ! - YouTube',
        url: 'http://www.youtube.com/watch?v=_OBlgSz8sSM',
        datetime: datetime()
      }
    ],
    'world news': [
      {
        title: 'Google News',
        url: 'https://news.google.com/news?vanilla=1',
        datetime: datetime()
      }, {
        title: 'BBC - Homepage',
        url: 'http://www.bbc.co.uk/',
        datetime: datetime()
      }, {
        title: 'Fact-Based, In-Depth News | Al Jazeera America',
        url: 'http://america.aljazeera.com/',
        datetime: datetime()
      }, {
        title: 'Yahoo! News - Latest News & Headlines',
        url: 'http://news.yahoo.com/',
        datetime: datetime()
      }, {
        title: 'World News',
        url: 'http://www.reddit.com/r/worldnews/',
        datetime: datetime()
      }, {
        title: 'World News, Foreign Policy and International Affairs - HuffPost World',
        url: 'http://www.huffingtonpost.com/world/',
        datetime: datetime()
      }, {
        title: 'World News | Reuters.com',
        url: 'http://www.reuters.com/news/world',
        datetime: datetime()
      }, {
        title: 'World News and International Headlines : NPR',
        url: 'http://www.npr.org/sections/world/',
        datetime: datetime()
      }
    ],
    games: [
      {
        title: 'Play Burrito Bison Revenge, a free online game on Kongregate',
        url: 'http://www.kongregate.com/games/JuicyBeast/burrito-bison-revenge',
        datetime: datetime()
      }, {
        title: 'Play Red Remover, a free online game on Kongregate',
        url: 'http://www.kongregate.com/games/TheGameHomepage/red-remover',
        datetime: datetime()
      }, {
        title: 'Monkey Quest - Free Online Strategy Games from AddictingGames',
        url: 'http://www.addictinggames.com/strategy-games/monkey-quest-game.jsp?xid=ag_mq_featured_bananas-beware',
        datetime: datetime()
      }, {
        title: 'Plants vs Zombies - Game of The Year Online at Games.com: Play Free Online Games',
        url: 'http://www.games.com/play/popcap-games/plants-vs-zombies-game-of-the-year',
        datetime: datetime()
      }, {
        title: 'Word Battle Online at Games.com: Play Free Online Games',
        url: 'http://www.games.com/play/sia-fufla/word-battle',
        datetime: datetime()
      }, {
        title: 'Bush Whacker 2 Online at Games.com: Play Free Online Games',
        url: 'http://www.games.com/play/djarts-games/bush-whacker-2',
        datetime: datetime()
      }, {
        title: 'Kingdom Rush Online at Games.com: Play Free Online Games',
        url: 'http://www.games.com/play/armorgames/kingdom-rush',
        datetime: datetime()
      }, {
        title: '8 Ball Pool Multiplayer - A free Sports Game',
        url: 'http://www.miniclip.com/games/8-ball-pool-multiplayer/en/#t-h-h',
        datetime: datetime()
      }, {
        title: 'Soccer Stars - A free Sports Game',
        url: 'http://www.miniclip.com/games/soccer-stars/en/#t-c-a',
        datetime: datetime()
      }, {
        title: 'Marble Lines | Play Online - Yahoo Games',
        url: 'http://games.yahoo.com/game/marble-lines-flash.html',
        datetime: datetime()
      }, {
        title: 'Rockitty | Play Online - Yahoo Games',
        url: 'http://games.yahoo.com/game/rockitty-flash.html',
        datetime: datetime()
      }
    ],
    recipes: [
      {
        title: 'Allrecipes - Recipes and cooking confidence for home cooks everywhere',
        url: 'http://allrecipes.com/',
        datetime: datetime()
      }, {
        title: 'Epicurious.com: Recipes, Menus, Cooking Articles & Food Guides',
        url: 'http://www.epicurious.com/',
        datetime: datetime()
      }, {
        title: 'foodgawker | feed your eyes',
        url: 'http://foodgawker.com/',
        datetime: datetime()
      }, {
        title: 'Recipes, Party Food, Cooking Guides, Dinner Ideas, and Grocery Coupons - Delish.com',
        url: 'http://www.delish.com/',
        datetime: datetime()
      }, {
        title: 'Quick Recipes & Easy Recipe Ideas - Tablespoon',
        url: 'http://www.tablespoon.com/',
        datetime: datetime()
      }, {
        title: 'The Best Site For Recipes, Recommendations, Food And Cooking | Yummly',
        url: 'http://www.yummly.com/',
        datetime: datetime()
      }
    ],
    clothing: [
      {
        title: 'Backpacks Made in USA, Gear Bags & Backpack Accessories | Topo Designs',
        url: 'http://topodesigns.com/',
        datetime: datetime()
      }, {
        title: "J.Crew : Cashmere Sweaters, Women's Clothing & Dresses, Men's & Kids' Clothing | JCrew.com",
        url: 'http://www.jcrew.com/index.jsp',
        datetime: datetime()
      }, {
        title: 'Topshop USA - Womens Clothing - Womens Fashion - Topshop',
        url: 'http://us.topshop.com/?geoip=home',
        datetime: datetime()
      }, {
        title: 'Clothes, Shoes, and Accessories for Women and Men | Free Shipping on $50 | Banana Republic',
        url: 'http://bananarepublic.gap.com/',
        datetime: datetime()
      }, {
        title: 'American Apparel | Fashionable Basics. Sweatshop Free. Made in USA.',
        url: 'http://www.americanapparel.net/',
        datetime: datetime()
      }, {
        title: 'Clothing – Shop For Clothes, Shipped FREE | Zappos.com',
        url: 'http://www.zappos.com/clothing',
        datetime: datetime()
      }, {
        title: 'Forever 21 - Shop fashionable clothing for women, plus, girls, men',
        url: 'http://www.forever21.com/Product/Main.aspx?br=f21',
        datetime: datetime()
      }, {
        title: 'OBEY CLOTHING',
        url: 'http://www.obeyclothing.com/',
        datetime: datetime()
      }, {
        title: "Victoria's Secret Online Clothing Store - Women's Clothing and Styles",
        url: 'http://www.victoriassecret.com/clothing',
        datetime: datetime()
      }, {
        title: 'Amazon.com Clothing: Denim, Dresses, T-Shirts & more + Free Returns',
        url: 'http://www.amazon.com/clothing-accessories-men-women-kids/b?ie=UTF8&node=1036592',
        datetime: datetime()
      }, {
        title: 'Urban Outfitters',
        url: 'http://www.urbanoutfitters.com/urban/index.jsp',
        datetime: datetime()
      }, {
        title: 'H&M | H&M US',
        url: 'http://www.hm.com/us/',
        datetime: datetime()
      }, {
        title: "Macy's - Shop Fashion Clothing & Accessories - Official Site - Macys.com",
        url: 'http://www.macys.com/',
        datetime: datetime()
      }, {
        title: 'Clothes For Women, Men, Kids and Baby | Free Shipping on $50 | Old Navy | Old Navy',
        url: 'http://www.oldnavy.com/',
        datetime: datetime()
      }
    ],
    'places to travel': [
      {
        title: 'Grand Canyon National Park - Grand Canyon National Park',
        url: 'http://www.nps.gov/grca/index.htm',
        datetime: datetime()
      }, {
        title: 'Great Wall of China - Wikipedia, the free encyclopedia',
        url: 'http://en.wikipedia.org/wiki/Great_Wall_of_China',
        datetime: datetime()
      }, {
        title: 'Nile River (river, Africa) -- Encyclopedia Britannica',
        url: 'http://www.britannica.com/EBchecked/topic/415347/Nile-River',
        datetime: datetime()
      }, {
        title: 'Travel Alaska - Official State of Alaska Travel &amp; Vacation Information',
        url: 'http://www.travelalaska.com/',
        datetime: datetime()
      }, {
        title: 'The London Pass® - London Sightseeing and Tourism for Less - London guide',
        url: 'http://www.londonpass.com/',
        datetime: datetime()
      }, {
        title: '10 Top Tourist Attractions in Germany | Touropia',
        url: 'http://www.touropia.com/tourist-attractions-in-germany/',
        datetime: datetime()
      }, {
        title: "France's Southern Vineyards : Wine : Travel Channel",
        url: 'http://www.travelchannel.com/interests/wine/articles/frances-southern-vineyards',
        datetime: datetime()
      }, {
        title: 'Things to do in Cuba – 275 Cuba Attractions - TripAdvisor',
        url: 'http://www.tripadvisor.ca/Attractions-g147270-Activities-Cuba.html',
        datetime: datetime()
      }, {
        title: 'Hawaii Vacations | Hawaii Vacation Packages and Deals',
        url: 'http://www.hawaii.com/',
        datetime: datetime()
      }
    ],
    productivity: [
      {
        title: 'Remember The Milk: Online to-do list and task management',
        url: 'http://www.rememberthemilk.com/',
        datetime: datetime()
      }, {
        title: 'Evernote | Remember everything with Evernote, Skitch and our other great apps.',
        url: 'http://evernote.com/',
        datetime: datetime()
      }, {
        title: 'Project management software, online collaboration: Basecamp',
        url: 'https://basecamp.com/',
        datetime: datetime()
      }, {
        title: 'HipChat',
        url: 'http://www.hipchat.com',
        datetime: datetime()
      }, {
        title: 'Skype - Free internet calls and cheap calls to phones online',
        url: 'http://www.skype.com/en/',
        datetime: datetime()
      }, {
        title: 'Dropbox',
        url: 'https://www.dropbox.com/',
        datetime: datetime()
      }
    ]
  };

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Lib.SyncingTranslator = (function() {

    function SyncingTranslator() {}

    SyncingTranslator.prototype.forServer = function(compiledTags, callback, options) {
      var foundIndex, index, requestImage, site, sites, storedSite, tag, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _results;
      if (options == null) {
        options = {};
      }
      sites = [];
      for (_i = 0, _len = compiledTags.length; _i < _len; _i++) {
        tag = compiledTags[_i];
        _ref = tag.sites;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          site = _ref[_j];
          if (site.url) {
            foundIndex = null;
            for (index = _k = 0, _len2 = sites.length; _k < _len2; index = ++_k) {
              storedSite = sites[index];
              if (storedSite.url === site.url) {
                foundIndex = index;
                break;
              }
            }
            if (foundIndex != null) {
              sites[foundIndex].tags.push(tag.name);
            } else {
              site.tags = [tag.name];
              sites.push(site);
            }
          }
        }
      }
      if (!options.skipImages) {
        index = 1;
        requestImage = function(site) {
          return BH.Lib.ImageData.base64("chrome://favicon/" + site.url, function(data) {
            site.image = data;
            if (index === sites.length) {
              return callback(sites);
            } else {
              return index++;
            }
          });
        };
        _results = [];
        for (_l = 0, _len3 = sites.length; _l < _len3; _l++) {
          site = sites[_l];
          _results.push(requestImage(site));
        }
        return _results;
      } else {
        return callback(sites);
      }
    };

    SyncingTranslator.prototype.addImageToSites = function(sites, callback) {
      var index, requestImage, site, _i, _len, _results;
      index = 1;
      requestImage = function(site) {
        return BH.Lib.ImageData.base64("chrome://favicon/" + site.url, function(data) {
          site.image = data;
          if (index === sites.length) {
            return callback(sites);
          } else {
            return index++;
          }
        });
      };
      _results = [];
      for (_i = 0, _len = sites.length; _i < _len; _i++) {
        site = sites[_i];
        _results.push(requestImage(site));
      }
      return _results;
    };

    SyncingTranslator.prototype.forLocal = function(sites) {
      var data, site, tag, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
      data = {
        tags: []
      };
      for (_i = 0, _len = sites.length; _i < _len; _i++) {
        site = sites[_i];
        _ref = site.tags;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          tag = _ref[_j];
          data.tags.push(tag);
        }
      }
      data.tags = _.uniq(data.tags);
      _ref1 = data.tags;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        tag = _ref1[_k];
        data[tag] = [];
      }
      for (_l = 0, _len3 = sites.length; _l < _len3; _l++) {
        site = sites[_l];
        if (site.datetime == null) {
          site.datetime = new Date().getTime();
        }
        _ref2 = site.tags;
        for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
          tag = _ref2[_m];
          data[tag].push({
            url: site.url,
            title: site.title,
            datetime: site.datetime
          });
        }
      }
      return data;
    };

    return SyncingTranslator;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var SitesHasher;

  SitesHasher = (function() {

    function SitesHasher(shaFunction, scope) {
      this.shaFunction = shaFunction;
      this.scope = scope != null ? scope : null;
      if (this.shaFunction == null) {
        throw "Need a sha function";
      }
    }

    SitesHasher.prototype.generate = function(sites) {
      var compiledString, data, site, stringifiedData, _i, _len;
      data = [];
      for (_i = 0, _len = sites.length; _i < _len; _i++) {
        site = sites[_i];
        if (site.tags.length > 0) {
          compiledString = "" + site.url + ": " + (site.tags.sort().join(', '));
          data.push(compiledString);
        }
      }
      stringifiedData = data.sort().join('|');
      if (data.length === 0) {
        return "";
      } else {
        return this.shaFunction.apply(this.scope, [stringifiedData]);
      }
    };

    return SitesHasher;

  })();

  if (typeof exports !== 'undefined') {
    module.exports = SitesHasher;
  } else {
    BH.Lib.SitesHasher = SitesHasher;
  }

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Migrations.EnsureDatetimeOnTaggedSites = (function() {

    EnsureDatetimeOnTaggedSites.prototype.name = 'ensure_datetime_on_tagged_sites';

    function EnsureDatetimeOnTaggedSites(options) {
      this.options = options;
    }

    EnsureDatetimeOnTaggedSites.prototype.run = function() {
      var updateTag,
        _this = this;
      updateTag = function(sites, name) {
        return persistence.tag().removeTag(name, function() {
          return persistence.tag().addSitesToTag(sites, name);
        });
      };
      return persistence.tag().getCompletedMigrations(function(migrations) {
        if (migrations.indexOf(_this.name) === -1) {
          persistence.tag().fetchTags(function(tags, compiledTags) {
            var compiledTag, modified, modifiedSites, site, _i, _j, _len, _len1, _ref, _results;
            _results = [];
            for (_i = 0, _len = compiledTags.length; _i < _len; _i++) {
              compiledTag = compiledTags[_i];
              modifiedSites = [];
              modified = false;
              _ref = compiledTag.sites;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                site = _ref[_j];
                if (site.datetime == null) {
                  site.datetime = new Date().getTime();
                  modified = true;
                }
                modifiedSites.push(site);
              }
              if (modified) {
                _results.push(updateTag(modifiedSites, compiledTag.name));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
          return persistence.tag().markMigrationAsComplete(_this.name, function() {
            return _this.options.analyticsTracker.ensureDatetimeOnTaggedSitesMigration();
          });
        }
      });
    };

    return EnsureDatetimeOnTaggedSites;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Persistence.Tag = (function() {

    function Tag(options) {
      if (options.localStore == null) {
        throw "Localstore is not set";
      }
      this.localStore = options.localStore;
    }

    Tag.prototype.setSitesHash = function(sitesHash) {
      return this.localStore.set({
        sitesHash: sitesHash
      }, function() {});
    };

    Tag.prototype.getSitesHash = function(callback) {
      return this.localStore.get('sitesHash', function(data) {
        return callback(data);
      });
    };

    Tag.prototype.getCompletedMigrations = function(callback) {
      return this.localStore.get('completedMigrations', function(data) {
        return callback(data.completedMigrations || []);
      });
    };

    Tag.prototype.markMigrationAsComplete = function(name, callback) {
      var _this = this;
      return this.localStore.get('completedMigrations', function(data) {
        data.completedMigrations || (data.completedMigrations = []);
        data.completedMigrations.push(name);
        return _this.localStore.set(data, function() {
          return callback();
        });
      });
    };

    Tag.prototype.cached = function(callback) {
      return this.localStore.get(null, function(data) {
        return callback({
          siteTags: function(url) {
            var matches, result, tag, _i, _len, _ref;
            matches = [];
            _ref = data.tags;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              tag = _ref[_i];
              result = _.where(data[tag], {
                url: url
              });
              if (result.length > 0) {
                matches.push(tag);
              }
            }
            return matches;
          },
          sitesTags: function(urls) {
            var matches, result, siteTags, tag, url, _i, _j, _len, _len1, _ref;
            siteTags = [];
            for (_i = 0, _len = urls.length; _i < _len; _i++) {
              url = urls[_i];
              matches = [];
              _ref = data.tags;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                tag = _ref[_j];
                result = _.where(data[tag], {
                  url: url
                });
                if (result.length > 0) {
                  matches.push(tag);
                }
              }
              siteTags.push(matches);
            }
            return _.intersection.apply(this, siteTags);
          }
        });
      });
    };

    Tag.prototype.fetchTags = function(callback) {
      var _this = this;
      return this.localStore.get('tags', function(data) {
        var tags;
        tags = data.tags || [];
        return _this.localStore.get(tags, function(data) {
          var compiledTags, foundTags, sites, tag;
          foundTags = [];
          compiledTags = (function() {
            var _results;
            _results = [];
            for (tag in data) {
              sites = data[tag];
              _results.push({
                name: tag,
                sites: sites
              });
            }
            return _results;
          })();
          return callback(tags, compiledTags);
        });
      });
    };

    Tag.prototype.fetchTagSites = function(name, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.localStore.get(name, function(data) {
        var site, sites;
        data[name] || (data[name] = []);
        sites = (function() {
          var _i, _len, _ref, _results;
          _ref = data[name];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            site = _ref[_i];
            _results.push({
              title: site.title,
              url: site.url,
              datetime: site.datetime
            });
          }
          return _results;
        })();
        return callback(sites);
      });
    };

    Tag.prototype.fetchSharedTag = function(name, callback) {
      return this.localStore.get('sharedTags', function(data) {
        data.sharedTags || (data.sharedTags = {});
        return callback(data.sharedTags[name]);
      });
    };

    Tag.prototype.fetchSiteTags = function(url, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.localStore.get('tags', function(data) {
        var tags;
        tags = data.tags || [];
        return _this.localStore.get(tags, function(data) {
          var foundTags, site, sites, tag, _i, _len;
          foundTags = [];
          for (tag in data) {
            sites = data[tag];
            for (_i = 0, _len = sites.length; _i < _len; _i++) {
              site = sites[_i];
              if (site.url === url) {
                foundTags.push(tag);
              }
            }
          }
          return callback(foundTags);
        });
      });
    };

    Tag.prototype.shareTag = function(tag, url, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.localStore.get("sharedTags", function(data) {
        if (data.sharedTags == null) {
          data = {
            sharedTags: {}
          };
        }
        data.sharedTags[tag] = url;
        return _this.localStore.set(data, function() {
          return callback();
        });
      });
    };

    Tag.prototype.addSiteToTag = function(site, tag, callback) {
      var operations,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      operations = {
        tagCreated: false
      };
      this.localStore.get("tags", function(data) {
        if (data.tags == null) {
          data = {
            tags: []
          };
        }
        if (data.tags.indexOf(tag) === -1) {
          operations.tagCreated = true;
          data.tags.unshift(tag);
        }
        return _this.localStore.set(data, function() {
          return _this.localStore.get(tag, function(data) {
            data[tag] || (data[tag] = []);
            data[tag].push(site);
            return _this.localStore.set(data, function() {
              return callback(operations);
            });
          });
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype.addSitesToTag = function(sites, tag, callback) {
      var operations,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      operations = {
        tagCreated: false
      };
      this.localStore.get("tags", function(data) {
        if (data.tags == null) {
          data = {
            tags: []
          };
        }
        if (data.tags.indexOf(tag) === -1) {
          operations.tagCreated = true;
          data.tags.unshift(tag);
        }
        return _this.localStore.set(data, function() {
          return _this.localStore.get(tag, function(data) {
            var site, _i, _len;
            for (_i = 0, _len = sites.length; _i < _len; _i++) {
              site = sites[_i];
              data[tag] || (data[tag] = []);
              data[tag].push(site);
            }
            return _this.localStore.set(data, function() {
              return callback(operations);
            });
          });
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype["import"] = function(data, callback) {
      return this.localStore.set(data, callback);
    };

    Tag.prototype.clearAll = function() {
      return this.localStore.clear();
    };

    Tag.prototype.removeSiteFromTag = function(url, tag, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get(tag, function(data) {
        data[tag] || (data[tag] = []);
        data[tag] = _.reject(data[tag], function(site) {
          return url === site.url;
        });
        return _this.localStore.set(data, function() {
          return callback(data[tag]);
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype.removeSitesFromTag = function(urls, tag, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get(tag, function(data) {
        data[tag] || (data[tag] = []);
        data[tag] = _.reject(data[tag], function(site) {
          return _.find(urls, function(url) {
            return site.url === url;
          });
        });
        return _this.localStore.set(data, function() {
          return callback(data[tag]);
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype.removeTag = function(tag, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get('tags', function(data) {
        data.tags || (data.tags = []);
        data.tags = _.without(data.tags, tag);
        return _this.localStore.set(data, function() {
          return _this.localStore.remove(tag, function() {
            return callback();
          });
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype.removeAllTags = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get('tags', function(data) {
        var tags;
        tags = data.tags || [];
        return _this.localStore.remove(tags, function() {
          return _this.localStore.set({
            tags: []
          }, function() {
            return callback();
          });
        });
      });
      return this.expireSharedTag();
    };

    Tag.prototype.renameTag = function(oldTag, newTag, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get('tags', function(data) {
        var newTagExists;
        data.tags || (data.tags = []);
        if (data.tags.indexOf(newTag) !== -1) {
          newTagExists = true;
        }
        data.tags = _.without(data.tags, oldTag);
        if (newTagExists) {
          data.tags = _.without(data.tags, newTag);
        }
        data.tags.unshift(newTag);
        return _this.localStore.set(data, function() {
          return _this.localStore.get(oldTag, function(data) {
            var sites;
            sites = data[oldTag];
            if (newTagExists) {
              return _this.localStore.get(newTag, function(data) {
                return _this.localStore.remove(oldTag, function() {
                  var site, _i, _len;
                  for (_i = 0, _len = sites.length; _i < _len; _i++) {
                    site = sites[_i];
                    data[newTag].push(site);
                  }
                  return _this.localStore.set(data, function() {
                    return callback();
                  });
                });
              });
            } else {
              return _this.localStore.remove(oldTag, function() {
                data = {};
                data[newTag] = sites;
                return _this.localStore.set(data, function() {
                  return callback();
                });
              });
            }
          });
        });
      });
      return this.expireSharedTag(oldTag);
    };

    Tag.prototype.expireSharedTag = function(tag, callback) {
      var _this = this;
      if (tag == null) {
        tag = null;
      }
      if (callback == null) {
        callback = function() {};
      }
      return this.localStore.get('sharedTags', function(data) {
        data.sharedTags || (data.sharedTags = {});
        if (tag != null) {
          delete data.sharedTags[tag];
        } else {
          data.sharedTags = {};
        }
        return _this.localStore.set(data, function() {
          return callback();
        });
      });
    };

    return Tag;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var error;

  error = function(data, type) {
    return tagState.set({
      readOnly: true
    });
  };

  BH.Persistence.Remote = (function() {

    function Remote(authId, ajax) {
      this.authId = authId;
      this.ajax = ajax;
    }

    Remote.prototype.host = function() {
      return "http://" + apiHost;
    };

    Remote.prototype.updateAuthId = function(authId) {
      return this.authId = authId;
    };

    Remote.prototype.performRequest = function(options) {
      var config,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (!navigator.onLine) {
        return error();
      }
      if (!options.disableSyncingFeedback) {
        tagState.set({
          syncing: true
        });
      }
      config = {
        url: this.host() + options.path,
        type: options.type,
        contentType: 'application/json',
        dataType: options.dataType || 'text',
        error: function(data, type) {
          if (data.status === 403) {
            user.logout();
            return chrome.identity.getAuthToken(function(token) {
              return chrome.identity.removeCachedAuthToken({
                token: token
              }, function() {
                var authErrorView;
                authErrorView = new BH.Views.AuthErrorView();
                return authErrorView.open();
              });
            });
          } else {
            error(data, type);
            if (options.error != null) {
              return options.error(data, type);
            }
          }
        },
        success: function(data) {
          tagState.set({
            readOnly: false
          });
          if (options.success != null) {
            return options.success(data);
          }
        },
        complete: function() {
          setTimeout(function() {
            return tagState.set({
              syncing: false
            });
          }, 1000);
          if (options.complete != null) {
            return options.complete();
          }
        }
      };
      if (options.authorization) {
        config.headers = {
          authorization: this.authId
        };
      }
      if (options.data != null) {
        config.data = JSON.stringify(options.data);
      }
      return this.ajax(config);
    };

    Remote.prototype.sitesHash = function(callback) {
      return this.performRequest({
        path: '/user/sites/hash',
        type: 'GET',
        dataType: 'json',
        authorization: true,
        disableSyncingFeedback: true,
        success: callback
      });
    };

    Remote.prototype.share = function(tagData, callbacks) {
      var params;
      params = {
        path: '/share',
        data: tagData,
        type: 'POST',
        dataType: 'json',
        success: callbacks.success,
        error: callbacks.error,
        disableSyncingFeedback: true,
        authorization: false
      };
      if (user.isLoggedIn()) {
        params.path = '/user/share';
        params.authorization = true;
      }
      return this.performRequest(params);
    };

    Remote.prototype.updateSite = function(site) {
      return this.performRequest({
        path: '/user/site',
        type: 'POST',
        data: site,
        authorization: true
      });
    };

    Remote.prototype.updateSites = function(sites, callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.performRequest({
        path: '/user/sites',
        type: 'POST',
        data: sites,
        success: callback,
        authorization: true
      });
    };

    Remote.prototype.getSites = function(callback) {
      return this.performRequest({
        path: '/user/sites',
        type: 'GET',
        dataType: 'json',
        success: callback,
        authorization: true
      });
    };

    Remote.prototype.renameTag = function(oldName, newName) {
      return this.performRequest({
        path: "/user/tags/" + (oldName.replace(/\s+/g, '-')) + "/rename",
        type: 'PUT',
        data: {
          name: newName
        },
        authorization: true
      });
    };

    Remote.prototype.deleteTag = function(name) {
      return this.performRequest({
        path: "/user/tags/" + (name.replace(/\s+/g, '-')),
        type: 'DELETE',
        authorization: true
      });
    };

    Remote.prototype.deleteSites = function(callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.performRequest({
        path: '/user/sites',
        type: 'DELETE',
        success: callback,
        authorization: true
      });
    };

    return Remote;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Init.TagFeature = (function() {

    function TagFeature(options) {
      this.syncStore = options.syncStore;
    }

    TagFeature.prototype.announce = function(callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.syncStore.get('tagInstructionsDismissed', function(data) {
        var tagInstructionsDismissed;
        tagInstructionsDismissed = data.tagInstructionsDismissed || false;
        if (!tagInstructionsDismissed) {
          return callback();
        }
      });
    };

    TagFeature.prototype.prepopulate = function(callback) {
      var _this = this;
      return this.syncStore.get('tagInstructionsDismissed', function(data) {
        var tagInstructionsDismissed;
        tagInstructionsDismissed = data.tagInstructionsDismissed || false;
        return persistence.tag().fetchTags(function(tags) {
          if (!tagInstructionsDismissed && tags.length === 0) {
            return callback();
          }
        });
      });
    };

    return TagFeature;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Init.Persistence = (function() {

    function Persistence(config) {
      this.config = config != null ? config : {};
    }

    Persistence.prototype.tag = function() {
      if (this.config.localStore == null) {
        throw "localStore requied";
      }
      return this.tagPersistence || (this.tagPersistence = new BH.Persistence.Tag({
        localStore: this.config.localStore
      }));
    };

    Persistence.prototype.remote = function(authId) {
      if (this.config.ajax == null) {
        throw "Ajax requied";
      }
      if (this.config.state == null) {
        throw "State required";
      }
      authId = authId || user.get('authId');
      this.remotePersistence || (this.remotePersistence = new BH.Persistence.Remote(authId, this.config.ajax, this.config.state));
      if (authId != null) {
        this.remotePersistence.updateAuthId(authId);
      }
      return this.remotePersistence;
    };

    return Persistence;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var analyticsTracker, errorTracker, load;

  window.apiHost = 'api.better-history.com';

  window.siteHost = 'www.better-history.com';

  window.env = 'prod';

  errorTracker = new BH.Trackers.ErrorTracker(Honeybadger);

  analyticsTracker = new BH.Trackers.AnalyticsTracker();

  load = function() {
    var omnibox, tagFeature,
      _this = this;
    window.syncStore = new BH.Lib.SyncStore({
      chrome: chrome,
      tracker: analyticsTracker
    });
    window.persistence = new BH.Init.Persistence({
      localStore: new BH.Lib.LocalStore({
        chrome: chrome,
        tracker: analyticsTracker
      }),
      syncStore: new BH.Lib.SyncStore({
        chrome: chrome,
        tracker: analyticsTracker
      })
    });
    chrome.runtime.onInstalled.addListener(function() {
      var ensureDatetimeOnTaggedSites;
      ensureDatetimeOnTaggedSites = new BH.Migrations.EnsureDatetimeOnTaggedSites({
        analyticsTracker: analyticsTracker
      });
      return ensureDatetimeOnTaggedSites.run();
    });
    omnibox = new BH.Lib.Omnibox({
      chrome: chrome,
      tracker: analyticsTracker
    });
    omnibox.listen();
    window.selectionContextMenu = new BH.Lib.SelectionContextMenu({
      chrome: chrome,
      tracker: analyticsTracker
    });
    window.pageContextMenu = new BH.Lib.PageContextMenu({
      chrome: chrome,
      tracker: analyticsTracker
    });
    pageContextMenu.listenToTabs();
    syncStore.get('settings', function(data) {
      var settings;
      settings = data.settings || {};
      if (settings.searchBySelection !== false) {
        selectionContextMenu.create();
      }
      if (settings.searchByDomain !== false) {
        return pageContextMenu.create();
      }
    });
    tagFeature = new BH.Init.TagFeature({
      syncStore: syncStore
    });
    tagFeature.prepopulate(function() {
      var exampleTags;
      exampleTags = new BH.Lib.ExampleTags();
      return exampleTags.load();
    });
    return chrome.runtime.onMessage.addListener(function(message) {
      var _this = this;
      if (message.action === 'calculate hash') {
        return persistence.tag().fetchTags(function(tags, compiledTags) {
          var syncingTranslator;
          if (tags.length > 0) {
            syncingTranslator = new BH.Lib.SyncingTranslator();
            return syncingTranslator.forServer(compiledTags, function(sites) {
              var sitesHash, sitesHasher;
              sitesHasher = new BH.Lib.SitesHasher(CryptoJS.SHA1);
              sitesHash = sitesHasher.generate(sites).toString();
              return persistence.tag().setSitesHash(sitesHash);
            }, {
              skipImages: true
            });
          } else {
            return persistence.tag().setSitesHash('');
          }
        });
      }
    });
  };

  if (env === 'prod') {
    try {
      load();
    } catch (e) {
      errorTracker.report(e);
    }
  } else {
    load();
  }

}).call(this);



