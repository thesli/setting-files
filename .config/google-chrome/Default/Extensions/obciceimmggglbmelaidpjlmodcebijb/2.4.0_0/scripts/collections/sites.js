// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Collections.Sites = (function(_super) {

    __extends(Sites, _super);

    function Sites() {
      return Sites.__super__.constructor.apply(this, arguments);
    }

    Sites.prototype.model = BH.Models.Site;

    Sites.prototype.fetch = function() {
      var callback, index,
        _this = this;
      index = 1;
      callback = function() {
        if (index === _this.length) {
          return _this.trigger('reset:allTags');
        } else {
          return index++;
        }
      };
      return this.each(function(model) {
        return model.fetch(callback);
      });
    };

    Sites.prototype.sharedTags = function() {
      return _.intersection.apply(this, this.pluck('tags'));
    };

    Sites.prototype.tags = function() {
      return this.sharedTags();
    };

    Sites.prototype.addTag = function(tag, callback) {
      var sites,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      tag = tag.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      if (tag.length === 0 || tag.match(/[\"\'\~\,\.\|\(\)\{\}\[\]\;\:\<\>\^\*\%\^]/)) {
        callback(false, null);
        return;
      }
      sites = [];
      this.each(function(model) {
        var newTags;
        if (model.get('tags').indexOf(tag) === -1) {
          newTags = _.clone(model.get('tags'));
          newTags.push(tag);
          model.set({
            tags: newTags
          });
          return sites.push({
            url: model.get('url'),
            title: model.get('title'),
            datetime: model.get('datetime') || new Date().getTime()
          });
        }
      });
      return persistence.tag().addSitesToTag(sites, tag, function(operations) {
        var translator;
        if (user.isLoggedIn()) {
          translator = new BH.Lib.SyncingTranslator();
          translator.addImageToSites(_this.toJSON(), function(compiledSites) {
            return persistence.remote().updateSites(compiledSites);
          });
        }
        chrome.runtime.sendMessage({
          action: 'calculate hash'
        });
        _this.trigger('change:allTags');
        return callback(true, operations);
      });
    };

    Sites.prototype.removeTag = function(tag, callback) {
      var sites,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      tag = tag.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      if (tag.length === 0) {
        return false;
      }
      sites = [];
      this.each(function(model) {
        var newTags;
        if (model.get('tags').indexOf(tag) !== -1) {
          newTags = _.clone(model.get('tags'));
          model.set({
            tags: _.without(newTags, tag)
          });
          return sites.push(model.get('url'));
        }
      });
      return persistence.tag().removeSitesFromTag(sites, tag, function() {
        var translator;
        if (user.isLoggedIn()) {
          translator = new BH.Lib.SyncingTranslator();
          translator.addImageToSites(_this.toJSON(), function(compiledSites) {
            return persistence.remote().updateSites(compiledSites);
          });
        }
        chrome.runtime.sendMessage({
          action: 'calculate hash'
        });
        _this.trigger('change:allTags');
        return callback();
      });
    };

    return Sites;

  })(Backbone.Collection);

}).call(this);
