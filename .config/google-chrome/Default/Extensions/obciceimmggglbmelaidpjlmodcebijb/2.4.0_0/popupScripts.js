// Generated by CoffeeScript 1.6.1
(function() {

  this.BH = {
    Views: {},
    Modals: {},
    Models: {},
    Collections: {},
    Lib: {
      ContextMenus: {}
    },
    Modules: {},
    Templates: {},
    Trackers: {},
    Presenters: {},
    Persistence: {},
    Migrations: {},
    Init: {},
    Chrome: {},
    Base: function() {}
  };

  if (typeof onServer !== "undefined" && onServer !== null) {
    module.exports = this.BH;
  }

}).call(this);



!function(){!function(window,undefined){var TraceKit={};var _oldTraceKit=window.TraceKit;var _slice=[].slice;var UNKNOWN_FUNCTION="?";function _has(object,key){return Object.prototype.hasOwnProperty.call(object,key)}function _isUndefined(what){return typeof what==="undefined"}TraceKit.noConflict=function noConflict(){window.TraceKit=_oldTraceKit;return TraceKit};TraceKit.wrap=function traceKitWrapper(func){function wrapped(){try{return func.apply(this,arguments)}catch(e){TraceKit.report(e);throw e}}return wrapped};TraceKit.report=function reportModuleWrapper(){var handlers=[],lastException=null,lastExceptionStack=null;function subscribe(handler){installGlobalHandler();handlers.push(handler)}function unsubscribe(handler){for(var i=handlers.length-1;i>=0;--i){if(handlers[i]===handler){handlers.splice(i,1)}}}function notifyHandlers(stack,windowError){var exception=null;if(windowError&&!TraceKit.collectWindowErrors){return}for(var i in handlers){if(_has(handlers,i)){try{handlers[i].apply(null,[stack].concat(_slice.call(arguments,2)))}catch(inner){exception=inner}}}if(exception){throw exception}}var _oldOnerrorHandler,_onErrorHandlerInstalled;function traceKitWindowOnError(message,url,lineNo){var stack=null;if(lastExceptionStack){TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack,url,lineNo,message);stack=lastExceptionStack;lastExceptionStack=null;lastException=null}else{var location={url:url,line:lineNo};location.func=TraceKit.computeStackTrace.guessFunctionName(location.url,location.line);location.context=TraceKit.computeStackTrace.gatherContext(location.url,location.line);stack={mode:"onerror",message:message,url:document.location.href,stack:[location],useragent:navigator.userAgent}}notifyHandlers(stack,"from window.onerror");if(_oldOnerrorHandler){return _oldOnerrorHandler.apply(this,arguments)}return false}function installGlobalHandler(){if(_onErrorHandlerInstalled===true){return}_oldOnerrorHandler=window.onerror;window.onerror=traceKitWindowOnError;_onErrorHandlerInstalled=true}function report(ex){var args=_slice.call(arguments,1);if(lastExceptionStack){if(lastException===ex){return}else{var s=lastExceptionStack;lastExceptionStack=null;lastException=null;notifyHandlers.apply(null,[s,null].concat(args))}}var stack=TraceKit.computeStackTrace(ex);lastExceptionStack=stack;lastException=ex;window.setTimeout(function(){if(lastException===ex){lastExceptionStack=null;lastException=null;notifyHandlers.apply(null,[stack,null].concat(args))}},stack.incomplete?2e3:0);throw ex}report.subscribe=subscribe;report.unsubscribe=unsubscribe;return report}();TraceKit.computeStackTrace=function computeStackTraceWrapper(){var debug=false,sourceCache={};function loadSource(url){if(!TraceKit.remoteFetching){return""}try{function getXHR(){try{return new window.XMLHttpRequest}catch(e){return new window.ActiveXObject("Microsoft.XMLHTTP")}}var request=getXHR();request.open("GET",url,false);request.send("");return request.responseText}catch(e){return""}}function getSource(url){if(!_has(sourceCache,url)){var source="";if(url.indexOf(document.domain)!==-1){source=loadSource(url)}sourceCache[url]=source?source.split("\n"):[]}return sourceCache[url]}function guessFunctionName(url,lineNo){var reFunctionArgNames=/function ([^(]*)\(([^)]*)\)/,reGuessFunction=/['"]?([0-9A-Za-z$_]+)['"]?\s*[:=]\s*(function|eval|new Function)/,line="",maxLines=10,source=getSource(url),m;if(!source.length){return UNKNOWN_FUNCTION}for(var i=0;i<maxLines;++i){line=source[lineNo-i]+line;if(!_isUndefined(line)){if(m=reGuessFunction.exec(line)){return m[1]}else if(m=reFunctionArgNames.exec(line)){return m[1]}}}return UNKNOWN_FUNCTION}function gatherContext(url,line){var source=getSource(url);if(!source.length){return null}var context=[],linesBefore=Math.floor(TraceKit.linesOfContext/2),linesAfter=linesBefore+TraceKit.linesOfContext%2,start=Math.max(0,line-linesBefore-1),end=Math.min(source.length,line+linesAfter-1);line-=1;for(var i=start;i<end;++i){if(!_isUndefined(source[i])){context.push(source[i])}}return context.length>0?context:null}function escapeRegExp(text){return text.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g,"\\$&")}function escapeCodeAsRegExpForMatchingInsideHTML(body){return escapeRegExp(body).replace("<","(?:<|&lt;)").replace(">","(?:>|&gt;)").replace("&","(?:&|&amp;)").replace('"','(?:"|&quot;)').replace(/\s+/g,"\\s+")}function findSourceInUrls(re,urls){var source,m;for(var i=0,j=urls.length;i<j;++i){if((source=getSource(urls[i])).length){source=source.join("\n");if(m=re.exec(source)){return{url:urls[i],line:source.substring(0,m.index).split("\n").length,column:m.index-source.lastIndexOf("\n",m.index)-1}}}}return null}function findSourceInLine(fragment,url,line){var source=getSource(url),re=new RegExp("\\b"+escapeRegExp(fragment)+"\\b"),m;line-=1;if(source&&source.length>line&&(m=re.exec(source[line]))){return m.index}return null}function findSourceByFunctionBody(func){var urls=[window.location.href],scripts=document.getElementsByTagName("script"),body,code=""+func,codeRE=/^function(?:\s+([\w$]+))?\s*\(([\w\s,]*)\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,eventRE=/^function on([\w$]+)\s*\(event\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,re,parts,result;for(var i=0;i<scripts.length;++i){var script=scripts[i];if(script.src){urls.push(script.src)}}if(!(parts=codeRE.exec(code))){re=new RegExp(escapeRegExp(code).replace(/\s+/g,"\\s+"))}else{var name=parts[1]?"\\s+"+parts[1]:"",args=parts[2].split(",").join("\\s*,\\s*");body=escapeRegExp(parts[3]).replace(/;$/,";?");re=new RegExp("function"+name+"\\s*\\(\\s*"+args+"\\s*\\)\\s*{\\s*"+body+"\\s*}")}if(result=findSourceInUrls(re,urls)){return result}if(parts=eventRE.exec(code)){var event=parts[1];body=escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);re=new RegExp("on"+event+"=[\\'\"]\\s*"+body+"\\s*[\\'\"]","i");if(result=findSourceInUrls(re,urls[0])){return result}re=new RegExp(body);if(result=findSourceInUrls(re,urls)){return result}}return null}function computeStackTraceFromStackProp(ex){if(!ex.stack){return null}var chrome=/^\s*at (?:((?:\[object object\])?\S+(?: \[as \S+\])?) )?\(?((?:file|http|https):.*?):(\d+)(?::(\d+))?\)?\s*$/i,gecko=/^\s*(\S*)(?:\((.*?)\))?@((?:file|http|https).*?):(\d+)(?::(\d+))?\s*$/i,lines=ex.stack.split("\n"),stack=[],parts,element,reference=/^(.*) is undefined$/.exec(ex.message);for(var i=0,j=lines.length;i<j;++i){if(parts=gecko.exec(lines[i])){element={url:parts[3],func:parts[1]||UNKNOWN_FUNCTION,args:parts[2]?parts[2].split(","):"",line:+parts[4],column:parts[5]?+parts[5]:null}}else if(parts=chrome.exec(lines[i])){element={url:parts[2],func:parts[1]||UNKNOWN_FUNCTION,line:+parts[3],column:parts[4]?+parts[4]:null}}else{continue}if(!element.func&&element.line){element.func=guessFunctionName(element.url,element.line)}if(element.line){element.context=gatherContext(element.url,element.line)}stack.push(element)}if(stack[0]&&stack[0].line&&!stack[0].column&&reference){stack[0].column=findSourceInLine(reference[1],stack[0].url,stack[0].line)}if(!stack.length){return null}return{mode:"stack",name:ex.name,message:ex.message,url:document.location.href,stack:stack,useragent:navigator.userAgent}}function computeStackTraceFromStacktraceProp(ex){var stacktrace=ex.stacktrace;var testRE=/ line (\d+), column (\d+) in (?:<anonymous function: ([^>]+)>|([^\)]+))\((.*)\) in (.*):\s*$/i,lines=stacktrace.split("\n"),stack=[],parts;for(var i=0,j=lines.length;i<j;i+=2){if(parts=testRE.exec(lines[i])){var element={line:+parts[1],column:+parts[2],func:parts[3]||parts[4],args:parts[5]?parts[5].split(","):[],url:parts[6]};if(!element.func&&element.line){element.func=guessFunctionName(element.url,element.line)}if(element.line){try{element.context=gatherContext(element.url,element.line)}catch(exc){}}if(!element.context){element.context=[lines[i+1]]}stack.push(element)}}if(!stack.length){return null}return{mode:"stacktrace",name:ex.name,message:ex.message,url:document.location.href,stack:stack,useragent:navigator.userAgent}}function computeStackTraceFromOperaMultiLineMessage(ex){var lines=ex.message.split("\n");if(lines.length<4){return null}var lineRE1=/^\s*Line (\d+) of linked script ((?:file|http|https)\S+)(?:: in function (\S+))?\s*$/i,lineRE2=/^\s*Line (\d+) of inline#(\d+) script in ((?:file|http|https)\S+)(?:: in function (\S+))?\s*$/i,lineRE3=/^\s*Line (\d+) of function script\s*$/i,stack=[],scripts=document.getElementsByTagName("script"),inlineScriptBlocks=[],parts,i,len,source;for(i in scripts){if(_has(scripts,i)&&!scripts[i].src){inlineScriptBlocks.push(scripts[i])}}for(i=2,len=lines.length;i<len;i+=2){var item=null;if(parts=lineRE1.exec(lines[i])){item={url:parts[2],func:parts[3],line:+parts[1]}}else if(parts=lineRE2.exec(lines[i])){item={url:parts[3],func:parts[4]};var relativeLine=+parts[1];var script=inlineScriptBlocks[parts[2]-1];if(script){source=getSource(item.url);if(source){source=source.join("\n");var pos=source.indexOf(script.innerText);if(pos>=0){item.line=relativeLine+source.substring(0,pos).split("\n").length}}}}else if(parts=lineRE3.exec(lines[i])){var url=window.location.href.replace(/#.*$/,""),line=parts[1];var re=new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[i+1]));source=findSourceInUrls(re,[url]);item={url:url,line:source?source.line:line,func:""}}if(item){if(!item.func){item.func=guessFunctionName(item.url,item.line)}var context=gatherContext(item.url,item.line);var midline=context?context[Math.floor(context.length/2)]:null;if(context&&midline.replace(/^\s*/,"")===lines[i+1].replace(/^\s*/,"")){item.context=context}else{item.context=[lines[i+1]]}stack.push(item)}}if(!stack.length){return null}return{mode:"multiline",name:ex.name,message:lines[0],url:document.location.href,stack:stack,useragent:navigator.userAgent}}function augmentStackTraceWithInitialElement(stackInfo,url,lineNo,message){var initial={url:url,line:lineNo};if(initial.url&&initial.line){stackInfo.incomplete=false;if(!initial.func){initial.func=guessFunctionName(initial.url,initial.line)}if(!initial.context){initial.context=gatherContext(initial.url,initial.line)}var reference=/ '([^']+)' /.exec(message);if(reference){initial.column=findSourceInLine(reference[1],initial.url,initial.line)}if(stackInfo.stack.length>0){if(stackInfo.stack[0].url===initial.url){if(stackInfo.stack[0].line===initial.line){return false}else if(!stackInfo.stack[0].line&&stackInfo.stack[0].func===initial.func){stackInfo.stack[0].line=initial.line;stackInfo.stack[0].context=initial.context;return false}}}stackInfo.stack.unshift(initial);stackInfo.partial=true;return true}else{stackInfo.incomplete=true}return false}function computeStackTraceByWalkingCallerChain(ex,depth){var functionName=/function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,stack=[],funcs={},recursion=false,parts,item,source;for(var curr=computeStackTraceByWalkingCallerChain.caller;curr&&!recursion;curr=curr.caller){if(curr===computeStackTrace||curr===TraceKit.report){continue}item={url:null,func:UNKNOWN_FUNCTION,line:null,column:null};if(curr.name){item.func=curr.name}else if(parts=functionName.exec(curr.toString())){item.func=parts[1]}if(source=findSourceByFunctionBody(curr)){item.url=source.url;item.line=source.line;if(item.func===UNKNOWN_FUNCTION){item.func=guessFunctionName(item.url,item.line)}var reference=/ '([^']+)' /.exec(ex.message||ex.description);if(reference){item.column=findSourceInLine(reference[1],source.url,source.line)}}if(funcs[""+curr]){recursion=true}else{funcs[""+curr]=true}stack.push(item)}if(depth){stack.splice(0,depth)}var result={mode:"callers",name:ex.name,message:ex.message,url:document.location.href,stack:stack,useragent:navigator.userAgent};augmentStackTraceWithInitialElement(result,ex.sourceURL||ex.fileName,ex.line||ex.lineNumber,ex.message||ex.description);return result}function computeStackTrace(ex,depth){var stack=null;depth=depth==null?0:+depth;try{stack=computeStackTraceFromStacktraceProp(ex);if(stack){return stack}}catch(e){if(debug){throw e}}try{stack=computeStackTraceFromStackProp(ex);if(stack){return stack}}catch(e){if(debug){throw e}}try{stack=computeStackTraceFromOperaMultiLineMessage(ex);if(stack){return stack}}catch(e){if(debug){throw e}}try{stack=computeStackTraceByWalkingCallerChain(ex,depth+1);if(stack){return stack}}catch(e){if(debug){throw e}}return{mode:"failed"}}function computeStackTraceOfCaller(depth){depth=(depth==null?0:+depth)+1;try{throw new Error}catch(ex){return computeStackTrace(ex,depth+1)}return null}computeStackTrace.augmentStackTraceWithInitialElement=augmentStackTraceWithInitialElement;computeStackTrace.guessFunctionName=guessFunctionName;computeStackTrace.gatherContext=gatherContext;computeStackTrace.ofCaller=computeStackTraceOfCaller;return computeStackTrace}();!function extendToAsynchronousCallbacks(){var _helper=function _helper(fnName){var originalFn=window[fnName];window[fnName]=function traceKitAsyncExtension(){var args=_slice.call(arguments);var originalCallback=args[0];if(typeof originalCallback==="function"){args[0]=TraceKit.wrap(originalCallback)}if(originalFn.apply){return originalFn.apply(this,args)}else{return originalFn(args[0],args[1])}}};_helper("setTimeout");_helper("setInterval")}();if(!TraceKit.remoteFetching){TraceKit.remoteFetching=true}if(!TraceKit.collectWindowErrors){TraceKit.collectWindowErrors=true}if(!TraceKit.linesOfContext||TraceKit.linesOfContext<1){TraceKit.linesOfContext=11}window.TraceKit=TraceKit}(window);var Notice;Notice=function(){function Notice(options){var k,v,_ref,_ref1,_ref2,_ref3,_ref4;this.options=options!=null?options:{};this.stackInfo=this.options.stackInfo||this.options.error&&TraceKit.computeStackTrace(this.options.error);this.trace=this._parseBacktrace((_ref=this.stackInfo)!=null?_ref.stack:void 0);this["class"]=(_ref1=this.stackInfo)!=null?_ref1.name:void 0;this.message=(_ref2=this.stackInfo)!=null?_ref2.message:void 0;this.source=this.stackInfo&&this._extractSource(this.stackInfo.stack);this.url=document.URL;this.project_root=Honeybadger.configuration.project_root;this.environment=Honeybadger.configuration.environment;this.component=Honeybadger.configuration.component;this.action=Honeybadger.configuration.action;this.context={};_ref3=Honeybadger.context;for(k in _ref3){v=_ref3[k];this.context[k]=v}if(this.options.context){_ref4=this.options.context;for(k in _ref4){v=_ref4[k];this.context[k]=v}}}Notice.prototype.toJSON=function(){return JSON.stringify({notifier:{name:"honeybadger.js",url:"https://github.com/honeybadger-io/honeybadger-js",version:Honeybadger.version,language:"javascript"},error:{"class":this["class"],message:this.message,backtrace:this.trace,source:this.source},request:{url:this.url,component:this.component,action:this.action,context:this.context,cgi_data:this._cgiData()},server:{project_root:this.project_root,environment_name:this.environment}})};Notice.prototype._parseBacktrace=function(stack){var backtrace,trace,_i,_len,_ref,_ref1;if(stack==null){stack=[]}backtrace=[];for(_i=0,_len=stack.length;_i<_len;_i++){trace=stack[_i];if((_ref=trace.url)!=null?_ref.match(/honeybadger(?:\.min)?\.js/):void 0){continue}backtrace.push({file:((_ref1=trace.url)!=null?_ref1.replace(Honeybadger.configuration.project_root,"[PROJECT_ROOT]"):void 0)||"unknown",number:trace.line,method:trace.func})}return backtrace};Notice.prototype._extractSource=function(stack){var i,line,source,_i,_len,_ref,_ref1,_ref2;if(stack==null){stack=[]}source={};_ref2=(_ref=(_ref1=stack[0])!=null?_ref1.context:void 0)!=null?_ref:[];for(i=_i=0,_len=_ref2.length;_i<_len;i=++_i){line=_ref2[i];source[i]=line}return source};Notice.prototype._cgiData=function(){var data,k,v;data={};for(k in navigator){v=navigator[k];if(typeof v!=="object"){data[k.split(/(?=[A-Z][a-z]*)/).join("_").toUpperCase()]=v}}data["HTTP_USER_AGENT"]=data["USER_AGENT"];delete data["USER_AGENT"];if(document.referrer.match(/\S/)){data["HTTP_REFERER"]=document.referrer}return data};return Notice}();var Honeybadger;Honeybadger=function(){var _this=this;function Honeybadger(){}Honeybadger.version="0.0.2";Honeybadger.default_configuration={api_key:null,host:"api.honeybadger.io",ssl:true,project_root:window.location.protocol+"//"+window.location.host,environment:"production",component:null,action:null,disabled:true,onerror:false};Honeybadger.configured=false;Honeybadger.configure=function(options){var k,v;if(options==null){options={}}if(this.configured===false){if(typeof options.disabled==="undefined"){options["disabled"]=false}this.configured=true}for(k in options){v=options[k];this.configuration[k]=v}TraceKit.collectWindowErrors=this.configuration.onerror;return this};Honeybadger.configuration={reset:function(){var k,v,_ref;Honeybadger.configured=false;_ref=Honeybadger.default_configuration;for(k in _ref){v=_ref[k];Honeybadger.configuration[k]=v}TraceKit.collectWindowErrors=Honeybadger.configuration.onerror;return Honeybadger}};Honeybadger.configuration.reset();Honeybadger.context={};Honeybadger.resetContext=function(options){if(options==null){options={}}this.context=options;return this};Honeybadger.setContext=function(options){var k,v;if(options==null){options={}}for(k in options){v=options[k];this.context[k]=v}return this};Honeybadger.notify=function(error,options){var notice;if(options==null){options={}}if(this.configuration.disabled===true){return false}if(error){options["error"]=error}notice=new Notice(options);return this._sendRequest(notice.toJSON())};Honeybadger._sendRequest=function(data){var url;url="http"+(this.configuration.ssl&&"s"||"")+"://"+this.configuration.host+"/v1/notices.html";return this._crossDomainPost(url,data)};Honeybadger._crossDomainPost=function(url,payload){var form,iframe,input,uniqueNameOfFrame;iframe=document.createElement("iframe");uniqueNameOfFrame="_hb_"+(new Date).getTime();document.body.appendChild(iframe);iframe.style.display="none";iframe.contentWindow.name=uniqueNameOfFrame;form=document.createElement("form");form.target=uniqueNameOfFrame;form.action=url;form.method="POST";input=document.createElement("input");input.type="hidden";input.name="payload";input.value=payload;form.appendChild(input);input=document.createElement("input");input.type="hidden";input.name="api_key";input.value=this.configuration.api_key;form.appendChild(input);document.body.appendChild(form);return form.submit()};Honeybadger._handleTraceKitSubscription=function(stackInfo){return Honeybadger.notify(null,{stackInfo:stackInfo})};return Honeybadger}.call(this);TraceKit.report.subscribe(Honeybadger._handleTraceKitSubscription);(typeof exports!=="undefined"&&exports!==null?exports:this).Honeybadger=Honeybadger}.call(this);



//     Underscore.js 1.4.3
//     http://underscorejs.org
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // with specific `key:value` pairs.
  _.where = function(obj, attrs) {
    if (_.isEmpty(attrs)) return [];
    return _.filter(obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function(func, context) {
    var args, bound;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + (0 | Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = '' + ++idCounter;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);



/* Zepto v1.0rc1 - polyfill zepto event detect fx ajax form touch - zeptojs.com/license */
(function(a){String.prototype.trim===a&&(String.prototype.trim=function(){return this.replace(/^\s+/,"").replace(/\s+$/,"")}),Array.prototype.reduce===a&&(Array.prototype.reduce=function(b){if(this===void 0||this===null)throw new TypeError;var c=Object(this),d=c.length>>>0,e=0,f;if(typeof b!="function")throw new TypeError;if(d==0&&arguments.length==1)throw new TypeError;if(arguments.length>=2)f=arguments[1];else do{if(e in c){f=c[e++];break}if(++e>=d)throw new TypeError}while(!0);while(e<d)e in c&&(f=b.call(a,f,c[e],e,c)),e++;return f})})();var Zepto=function(){function A(a){return v.call(a)=="[object Function]"}function B(a){return a instanceof Object}function C(b){var c,d;if(v.call(b)!=="[object Object]")return!1;d=A(b.constructor)&&b.constructor.prototype;if(!d||!hasOwnProperty.call(d,"isPrototypeOf"))return!1;for(c in b);return c===a||hasOwnProperty.call(b,c)}function D(a){return a instanceof Array}function E(a){return typeof a.length=="number"}function F(b){return b.filter(function(b){return b!==a&&b!==null})}function G(a){return a.length>0?[].concat.apply([],a):a}function H(a){return a.replace(/::/g,"/").replace(/([A-Z]+)([A-Z][a-z])/g,"$1_$2").replace(/([a-z\d])([A-Z])/g,"$1_$2").replace(/_/g,"-").toLowerCase()}function I(a){return a in i?i[a]:i[a]=new RegExp("(^|\\s)"+a+"(\\s|$)")}function J(a,b){return typeof b=="number"&&!k[H(a)]?b+"px":b}function K(a){var b,c;return h[a]||(b=g.createElement(a),g.body.appendChild(b),c=j(b,"").getPropertyValue("display"),b.parentNode.removeChild(b),c=="none"&&(c="block"),h[a]=c),h[a]}function L(b,d){return d===a?c(b):c(b).filter(d)}function M(a,b,c,d){return A(b)?b.call(a,c,d):b}function N(a,b,d){var e=a%2?b:b.parentNode;e?e.insertBefore(d,a?a==1?e.firstChild:a==2?b:null:b.nextSibling):c(d).remove()}function O(a,b){b(a);for(var c in a.childNodes)O(a.childNodes[c],b)}var a,b,c,d,e=[],f=e.slice,g=window.document,h={},i={},j=g.defaultView.getComputedStyle,k={"column-count":1,columns:1,"font-weight":1,"line-height":1,opacity:1,"z-index":1,zoom:1},l=/^\s*<(\w+|!)[^>]*>/,m=[1,3,8,9,11],n=["after","prepend","before","append"],o=g.createElement("table"),p=g.createElement("tr"),q={tr:g.createElement("tbody"),tbody:o,thead:o,tfoot:o,td:p,th:p,"*":g.createElement("div")},r=/complete|loaded|interactive/,s=/^\.([\w-]+)$/,t=/^#([\w-]+)$/,u=/^[\w-]+$/,v={}.toString,w={},x,y,z=g.createElement("div");return w.matches=function(a,b){if(!a||a.nodeType!==1)return!1;var c=a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.matchesSelector;if(c)return c.call(a,b);var d,e=a.parentNode,f=!e;return f&&(e=z).appendChild(a),d=~w.qsa(e,b).indexOf(a),f&&z.removeChild(a),d},x=function(a){return a.replace(/-+(.)?/g,function(a,b){return b?b.toUpperCase():""})},y=function(a){return a.filter(function(b,c){return a.indexOf(b)==c})},w.fragment=function(b,d){d===a&&(d=l.test(b)&&RegExp.$1),d in q||(d="*");var e=q[d];return e.innerHTML=""+b,c.each(f.call(e.childNodes),function(){e.removeChild(this)})},w.Z=function(a,b){return a=a||[],a.__proto__=arguments.callee.prototype,a.selector=b||"",a},w.isZ=function(a){return a instanceof w.Z},w.init=function(b,d){if(!b)return w.Z();if(A(b))return c(g).ready(b);if(w.isZ(b))return b;var e;if(D(b))e=F(b);else if(C(b))e=[c.extend({},b)],b=null;else if(m.indexOf(b.nodeType)>=0||b===window)e=[b],b=null;else if(l.test(b))e=w.fragment(b.trim(),RegExp.$1),b=null;else{if(d!==a)return c(d).find(b);e=w.qsa(g,b)}return w.Z(e,b)},c=function(a,b){return w.init(a,b)},c.extend=function(c){return f.call(arguments,1).forEach(function(d){for(b in d)d[b]!==a&&(c[b]=d[b])}),c},w.qsa=function(a,b){var c;return a===g&&t.test(b)?(c=a.getElementById(RegExp.$1))?[c]:e:a.nodeType!==1&&a.nodeType!==9?e:f.call(s.test(b)?a.getElementsByClassName(RegExp.$1):u.test(b)?a.getElementsByTagName(b):a.querySelectorAll(b))},c.isFunction=A,c.isObject=B,c.isArray=D,c.isPlainObject=C,c.inArray=function(a,b,c){return e.indexOf.call(b,a,c)},c.trim=function(a){return a.trim()},c.uuid=0,c.map=function(a,b){var c,d=[],e,f;if(E(a))for(e=0;e<a.length;e++)c=b(a[e],e),c!=null&&d.push(c);else for(f in a)c=b(a[f],f),c!=null&&d.push(c);return G(d)},c.each=function(a,b){var c,d;if(E(a)){for(c=0;c<a.length;c++)if(b.call(a[c],c,a[c])===!1)return a}else for(d in a)if(b.call(a[d],d,a[d])===!1)return a;return a},c.fn={forEach:e.forEach,reduce:e.reduce,push:e.push,indexOf:e.indexOf,concat:e.concat,map:function(a){return c.map(this,function(b,c){return a.call(b,c,b)})},slice:function(){return c(f.apply(this,arguments))},ready:function(a){return r.test(g.readyState)?a(c):g.addEventListener("DOMContentLoaded",function(){a(c)},!1),this},get:function(b){return b===a?f.call(this):this[b]},toArray:function(){return this.get()},size:function(){return this.length},remove:function(){return this.each(function(){this.parentNode!=null&&this.parentNode.removeChild(this)})},each:function(a){return this.forEach(function(b,c){a.call(b,c,b)}),this},filter:function(a){return c([].filter.call(this,function(b){return w.matches(b,a)}))},add:function(a,b){return c(y(this.concat(c(a,b))))},is:function(a){return this.length>0&&w.matches(this[0],a)},not:function(b){var d=[];if(A(b)&&b.call!==a)this.each(function(a){b.call(this,a)||d.push(this)});else{var e=typeof b=="string"?this.filter(b):E(b)&&A(b.item)?f.call(b):c(b);this.forEach(function(a){e.indexOf(a)<0&&d.push(a)})}return c(d)},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){var a=this[0];return a&&!B(a)?a:c(a)},last:function(){var a=this[this.length-1];return a&&!B(a)?a:c(a)},find:function(a){var b;return this.length==1?b=w.qsa(this[0],a):b=this.map(function(){return w.qsa(this,a)}),c(b)},closest:function(a,b){var d=this[0];while(d&&!w.matches(d,a))d=d!==b&&d!==g&&d.parentNode;return c(d)},parents:function(a){var b=[],d=this;while(d.length>0)d=c.map(d,function(a){if((a=a.parentNode)&&a!==g&&b.indexOf(a)<0)return b.push(a),a});return L(b,a)},parent:function(a){return L(y(this.pluck("parentNode")),a)},children:function(a){return L(this.map(function(){return f.call(this.children)}),a)},siblings:function(a){return L(this.map(function(a,b){return f.call(b.parentNode.children).filter(function(a){return a!==b})}),a)},empty:function(){return this.each(function(){this.innerHTML=""})},pluck:function(a){return this.map(function(){return this[a]})},show:function(){return this.each(function(){this.style.display=="none"&&(this.style.display=null),j(this,"").getPropertyValue("display")=="none"&&(this.style.display=K(this.nodeName))})},replaceWith:function(a){return this.before(a).remove()},wrap:function(a){return this.each(function(){c(this).wrapAll(c(a)[0].cloneNode(!1))})},wrapAll:function(a){return this[0]&&(c(this[0]).before(a=c(a)),a.append(this)),this},unwrap:function(){return this.parent().each(function(){c(this).replaceWith(c(this).children())}),this},clone:function(){return c(this.map(function(){return this.cloneNode(!0)}))},hide:function(){return this.css("display","none")},toggle:function(b){return(b===a?this.css("display")=="none":b)?this.show():this.hide()},prev:function(){return c(this.pluck("previousElementSibling"))},next:function(){return c(this.pluck("nextElementSibling"))},html:function(b){return b===a?this.length>0?this[0].innerHTML:null:this.each(function(a){var d=this.innerHTML;c(this).empty().append(M(this,b,a,d))})},text:function(b){return b===a?this.length>0?this[0].textContent:null:this.each(function(){this.textContent=b})},attr:function(c,d){var e;return typeof c=="string"&&d===a?this.length==0||this[0].nodeType!==1?a:c=="value"&&this[0].nodeName=="INPUT"?this.val():!(e=this[0].getAttribute(c))&&c in this[0]?this[0][c]:e:this.each(function(a){if(this.nodeType!==1)return;if(B(c))for(b in c)this.setAttribute(b,c[b]);else this.setAttribute(c,M(this,d,a,this.getAttribute(c)))})},removeAttr:function(a){return this.each(function(){this.nodeType===1&&this.removeAttribute(a)})},prop:function(b,c){return c===a?this[0]?this[0][b]:a:this.each(function(a){this[b]=M(this,c,a,this[b])})},data:function(b,c){var d=this.attr("data-"+H(b),c);return d!==null?d:a},val:function(b){return b===a?this.length>0?this[0].value:a:this.each(function(a){this.value=M(this,b,a,this.value)})},offset:function(){if(this.length==0)return null;var a=this[0].getBoundingClientRect();return{left:a.left+window.pageXOffset,top:a.top+window.pageYOffset,width:a.width,height:a.height}},css:function(c,d){if(d===a&&typeof c=="string")return this.length==0?a:this[0].style[x(c)]||j(this[0],"").getPropertyValue(c);var e="";for(b in c)typeof c[b]=="string"&&c[b]==""?this.each(function(){this.style.removeProperty(H(b))}):e+=H(b)+":"+J(b,c[b])+";";return typeof c=="string"&&(d==""?this.each(function(){this.style.removeProperty(H(c))}):e=H(c)+":"+J(c,d)),this.each(function(){this.style.cssText+=";"+e})},index:function(a){return a?this.indexOf(c(a)[0]):this.parent().children().indexOf(this[0])},hasClass:function(a){return this.length<1?!1:I(a).test(this[0].className)},addClass:function(a){return this.each(function(b){d=[];var e=this.className,f=M(this,a,b,e);f.split(/\s+/g).forEach(function(a){c(this).hasClass(a)||d.push(a)},this),d.length&&(this.className+=(e?" ":"")+d.join(" "))})},removeClass:function(b){return this.each(function(c){if(b===a)return this.className="";d=this.className,M(this,b,c,d).split(/\s+/g).forEach(function(a){d=d.replace(I(a)," ")}),this.className=d.trim()})},toggleClass:function(b,d){return this.each(function(e){var f=M(this,b,e,this.className);(d===a?!c(this).hasClass(f):d)?c(this).addClass(f):c(this).removeClass(f)})}},["width","height"].forEach(function(b){c.fn[b]=function(d){var e,f=b.replace(/./,function(a){return a[0].toUpperCase()});return d===a?this[0]==window?window["inner"+f]:this[0]==g?g.documentElement["offset"+f]:(e=this.offset())&&e[b]:this.each(function(a){var e=c(this);e.css(b,M(this,d,a,e[b]()))})}}),n.forEach(function(a,b){c.fn[a]=function(){var a=c.map(arguments,function(a){return B(a)?a:w.fragment(a)});if(a.length<1)return this;var d=this.length,e=d>1,f=b<2;return this.each(function(c,g){for(var h=0;h<a.length;h++){var i=a[f?a.length-h-1:h];O(i,function(a){a.nodeName!=null&&a.nodeName.toUpperCase()==="SCRIPT"&&(!a.type||a.type==="text/javascript")&&window.eval.call(window,a.innerHTML)}),e&&c<d-1&&(i=i.cloneNode(!0)),N(b,g,i)}})},c.fn[b%2?a+"To":"insert"+(b?"Before":"After")]=function(b){return c(b)[a](this),this}}),w.Z.prototype=c.fn,w.camelize=x,w.uniq=y,c.zepto=w,c}();window.Zepto=Zepto,"$"in window||(window.$=Zepto),function(a){function f(a){return a._zid||(a._zid=d++)}function g(a,b,d,e){b=h(b);if(b.ns)var g=i(b.ns);return(c[f(a)]||[]).filter(function(a){return a&&(!b.e||a.e==b.e)&&(!b.ns||g.test(a.ns))&&(!d||f(a.fn)===f(d))&&(!e||a.sel==e)})}function h(a){var b=(""+a).split(".");return{e:b[0],ns:b.slice(1).sort().join(" ")}}function i(a){return new RegExp("(?:^| )"+a.replace(" "," .* ?")+"(?: |$)")}function j(b,c,d){a.isObject(b)?a.each(b,d):b.split(/\s/).forEach(function(a){d(a,c)})}function k(b,d,e,g,i,k){k=!!k;var l=f(b),m=c[l]||(c[l]=[]);j(d,e,function(c,d){var e=i&&i(d,c),f=e||d,j=function(a){var c=f.apply(b,[a].concat(a.data));return c===!1&&a.preventDefault(),c},l=a.extend(h(c),{fn:d,proxy:j,sel:g,del:e,i:m.length});m.push(l),b.addEventListener(l.e,j,k)})}function l(a,b,d,e){var h=f(a);j(b||"",d,function(b,d){g(a,b,d,e).forEach(function(b){delete c[h][b.i],a.removeEventListener(b.e,b.proxy,!1)})})}function p(b){var c=a.extend({originalEvent:b},b);return a.each(o,function(a,d){c[a]=function(){return this[d]=m,b[a].apply(b,arguments)},c[d]=n}),c}function q(a){if(!("defaultPrevented"in a)){a.defaultPrevented=!1;var b=a.preventDefault;a.preventDefault=function(){this.defaultPrevented=!0,b.call(this)}}}var b=a.zepto.qsa,c={},d=1,e={};e.click=e.mousedown=e.mouseup=e.mousemove="MouseEvents",a.event={add:k,remove:l},a.proxy=function(b,c){if(a.isFunction(b)){var d=function(){return b.apply(c,arguments)};return d._zid=f(b),d}if(typeof c=="string")return a.proxy(b[c],b);throw new TypeError("expected function")},a.fn.bind=function(a,b){return this.each(function(){k(this,a,b)})},a.fn.unbind=function(a,b){return this.each(function(){l(this,a,b)})},a.fn.one=function(a,b){return this.each(function(c,d){k(this,a,b,null,function(a,b){return function(){var c=a.apply(d,arguments);return l(d,b,a),c}})})};var m=function(){return!0},n=function(){return!1},o={preventDefault:"isDefaultPrevented",stopImmediatePropagation:"isImmediatePropagationStopped",stopPropagation:"isPropagationStopped"};a.fn.delegate=function(b,c,d){var e=!1;if(c=="blur"||c=="focus")a.iswebkit?c=c=="blur"?"focusout":c=="focus"?"focusin":c:e=!0;return this.each(function(f,g){k(g,c,d,b,function(c){return function(d){var e,f=a(d.target).closest(b,g).get(0);if(f)return e=a.extend(p(d),{currentTarget:f,liveFired:g}),c.apply(f,[e].concat([].slice.call(arguments,1)))}},e)})},a.fn.undelegate=function(a,b,c){return this.each(function(){l(this,b,c,a)})},a.fn.live=function(b,c){return a(document.body).delegate(this.selector,b,c),this},a.fn.die=function(b,c){return a(document.body).undelegate(this.selector,b,c),this},a.fn.on=function(b,c,d){return c==undefined||a.isFunction(c)?this.bind(b,c):this.delegate(c,b,d)},a.fn.off=function(b,c,d){return c==undefined||a.isFunction(c)?this.unbind(b,c):this.undelegate(c,b,d)},a.fn.trigger=function(b,c){return typeof b=="string"&&(b=a.Event(b)),q(b),b.data=c,this.each(function(){"dispatchEvent"in this&&this.dispatchEvent(b)})},a.fn.triggerHandler=function(b,c){var d,e;return this.each(function(f,h){d=p(typeof b=="string"?a.Event(b):b),d.data=c,d.target=h,a.each(g(h,b.type||b),function(a,b){e=b.proxy(d);if(d.isImmediatePropagationStopped())return!1})}),e},"focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout change select keydown keypress keyup error".split(" ").forEach(function(b){a.fn[b]=function(a){return this.bind(b,a)}}),["focus","blur"].forEach(function(b){a.fn[b]=function(a){if(a)this.bind(b,a);else if(this.length)try{this.get(0)[b]()}catch(c){}return this}}),a.Event=function(a,b){var c=document.createEvent(e[a]||"Events"),d=!0;if(b)for(var f in b)f=="bubbles"?d=!!b[f]:c[f]=b[f];return c.initEvent(a,d,!0,null,null,null,null,null,null,null,null,null,null,null,null),c}}(Zepto),function(a){function b(a){var b=this.os={},c=this.browser={},d=a.match(/WebKit\/([\d.]+)/),e=a.match(/(Android)\s+([\d.]+)/),f=a.match(/(iPad).*OS\s([\d_]+)/),g=!f&&a.match(/(iPhone\sOS)\s([\d_]+)/),h=a.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),i=h&&a.match(/TouchPad/),j=a.match(/Kindle\/([\d.]+)/),k=a.match(/Silk\/([\d._]+)/),l=a.match(/(BlackBerry).*Version\/([\d.]+)/);if(c.webkit=!!d)c.version=d[1];e&&(b.android=!0,b.version=e[2]),g&&(b.ios=b.iphone=!0,b.version=g[2].replace(/_/g,".")),f&&(b.ios=b.ipad=!0,b.version=f[2].replace(/_/g,".")),h&&(b.webos=!0,b.version=h[2]),i&&(b.touchpad=!0),l&&(b.blackberry=!0,b.version=l[2]),j&&(b.kindle=!0,b.version=j[1]),k&&(c.silk=!0,c.version=k[1]),!k&&b.android&&a.match(/Kindle Fire/)&&(c.silk=!0)}b.call(a,navigator.userAgent),a.__detect=b}(Zepto),function(a,b){function l(a){return a.toLowerCase()}function m(a){return d?d+a:l(a)}var c="",d,e,f,g={Webkit:"webkit",Moz:"",O:"o",ms:"MS"},h=window.document,i=h.createElement("div"),j=/^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,k={};a.each(g,function(a,e){if(i.style[a+"TransitionProperty"]!==b)return c="-"+l(a)+"-",d=e,!1}),k[c+"transition-property"]=k[c+"transition-duration"]=k[c+"transition-timing-function"]=k[c+"animation-name"]=k[c+"animation-duration"]="",a.fx={off:d===b&&i.style.transitionProperty===b,cssPrefix:c,transitionEnd:m("TransitionEnd"),animationEnd:m("AnimationEnd")},a.fn.animate=function(b,c,d,e){return a.isObject(c)&&(d=c.easing,e=c.complete,c=c.duration),c&&(c/=1e3),this.anim(b,c,d,e)},a.fn.anim=function(d,e,f,g){var h,i={},l,m=this,n,o=a.fx.transitionEnd;e===b&&(e=.4),a.fx.off&&(e=0);if(typeof d=="string")i[c+"animation-name"]=d,i[c+"animation-duration"]=e+"s",o=a.fx.animationEnd;else{for(l in d)j.test(l)?(h||(h=[]),h.push(l+"("+d[l]+")")):i[l]=d[l];h&&(i[c+"transform"]=h.join(" ")),!a.fx.off&&typeof d=="object"&&(i[c+"transition-property"]=Object.keys(d).join(", "),i[c+"transition-duration"]=e+"s",i[c+"transition-timing-function"]=f||"linear")}return n=function(b){if(typeof b!="undefined"){if(b.target!==b.currentTarget)return;a(b.target).unbind(o,arguments.callee)}a(this).css(k),g&&g.call(this)},e>0&&this.bind(o,n),setTimeout(function(){m.css(i),e<=0&&setTimeout(function(){m.each(function(){n.call(this)})},0)},0),this},i=null}(Zepto),function($){function triggerAndReturn(a,b,c){var d=$.Event(b);return $(a).trigger(d,c),!d.defaultPrevented}function triggerGlobal(a,b,c,d){if(a.global)return triggerAndReturn(b||document,c,d)}function ajaxStart(a){a.global&&$.active++===0&&triggerGlobal(a,null,"ajaxStart")}function ajaxStop(a){a.global&&!--$.active&&triggerGlobal(a,null,"ajaxStop")}function ajaxBeforeSend(a,b){var c=b.context;if(b.beforeSend.call(c,a,b)===!1||triggerGlobal(b,c,"ajaxBeforeSend",[a,b])===!1)return!1;triggerGlobal(b,c,"ajaxSend",[a,b])}function ajaxSuccess(a,b,c){var d=c.context,e="success";c.success.call(d,a,e,b),triggerGlobal(c,d,"ajaxSuccess",[b,c,a]),ajaxComplete(e,b,c)}function ajaxError(a,b,c,d){var e=d.context;d.error.call(e,c,b,a),triggerGlobal(d,e,"ajaxError",[c,d,a]),ajaxComplete(b,c,d)}function ajaxComplete(a,b,c){var d=c.context;c.complete.call(d,b,a),triggerGlobal(c,d,"ajaxComplete",[b,c]),ajaxStop(c)}function empty(){}function mimeToDataType(a){return a&&(a==htmlType?"html":a==jsonType?"json":scriptTypeRE.test(a)?"script":xmlTypeRE.test(a)&&"xml")||"text"}function appendQuery(a,b){return(a+"&"+b).replace(/[&?]{1,2}/,"?")}function serializeData(a){isObject(a.data)&&(a.data=$.param(a.data)),a.data&&(!a.type||a.type.toUpperCase()=="GET")&&(a.url=appendQuery(a.url,a.data))}function serialize(a,b,c,d){var e=$.isArray(b);$.each(b,function(b,f){d&&(b=c?d:d+"["+(e?"":b)+"]"),!d&&e?a.add(f.name,f.value):(c?$.isArray(f):isObject(f))?serialize(a,f,c,b):a.add(b,f)})}var jsonpID=0,isObject=$.isObject,document=window.document,key,name,rscript=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,scriptTypeRE=/^(?:text|application)\/javascript/i,xmlTypeRE=/^(?:text|application)\/xml/i,jsonType="application/json",htmlType="text/html",blankRE=/^\s*$/;$.active=0,$.ajaxJSONP=function(a){var b="jsonp"+ ++jsonpID,c=document.createElement("script"),d=function(){$(c).remove(),b in window&&(window[b]=empty),ajaxComplete("abort",e,a)},e={abort:d},f;return a.error&&(c.onerror=function(){e.abort(),a.error()}),window[b]=function(d){clearTimeout(f),$(c).remove(),delete window[b],ajaxSuccess(d,e,a)},serializeData(a),c.src=a.url.replace(/=\?/,"="+b),$("head").append(c),a.timeout>0&&(f=setTimeout(function(){e.abort(),ajaxComplete("timeout",e,a)},a.timeout)),e},$.ajaxSettings={type:"GET",beforeSend:empty,success:empty,error:empty,complete:empty,context:null,global:!0,xhr:function(){return new window.XMLHttpRequest},accepts:{script:"text/javascript, application/javascript",json:jsonType,xml:"application/xml, text/xml",html:htmlType,text:"text/plain"},crossDomain:!1,timeout:0},$.ajax=function(options){var settings=$.extend({},options||{});for(key in $.ajaxSettings)settings[key]===undefined&&(settings[key]=$.ajaxSettings[key]);ajaxStart(settings),settings.crossDomain||(settings.crossDomain=/^([\w-]+:)?\/\/([^\/]+)/.test(settings.url)&&RegExp.$2!=window.location.host);var dataType=settings.dataType,hasPlaceholder=/=\?/.test(settings.url);if(dataType=="jsonp"||hasPlaceholder)return hasPlaceholder||(settings.url=appendQuery(settings.url,"callback=?")),$.ajaxJSONP(settings);settings.url||(settings.url=window.location.toString()),serializeData(settings);var mime=settings.accepts[dataType],baseHeaders={},protocol=/^([\w-]+:)\/\//.test(settings.url)?RegExp.$1:window.location.protocol,xhr=$.ajaxSettings.xhr(),abortTimeout;settings.crossDomain||(baseHeaders["X-Requested-With"]="XMLHttpRequest"),mime&&(baseHeaders.Accept=mime,mime.indexOf(",")>-1&&(mime=mime.split(",",2)[0]),xhr.overrideMimeType&&xhr.overrideMimeType(mime));if(settings.contentType||settings.data&&settings.type.toUpperCase()!="GET")baseHeaders["Content-Type"]=settings.contentType||"application/x-www-form-urlencoded";settings.headers=$.extend(baseHeaders,settings.headers||{}),xhr.onreadystatechange=function(){if(xhr.readyState==4){clearTimeout(abortTimeout);var result,error=!1;if(xhr.status>=200&&xhr.status<300||xhr.status==304||xhr.status==0&&protocol=="file:"){dataType=dataType||mimeToDataType(xhr.getResponseHeader("content-type")),result=xhr.responseText;try{dataType=="script"?(1,eval)(result):dataType=="xml"?result=xhr.responseXML:dataType=="json"&&(result=blankRE.test(result)?null:JSON.parse(result))}catch(e){error=e}error?ajaxError(error,"parsererror",xhr,settings):ajaxSuccess(result,xhr,settings)}else ajaxError(null,"error",xhr,settings)}};var async="async"in settings?settings.async:!0;xhr.open(settings.type,settings.url,async);for(name in settings.headers)xhr.setRequestHeader(name,settings.headers[name]);return ajaxBeforeSend(xhr,settings)===!1?(xhr.abort(),!1):(settings.timeout>0&&(abortTimeout=setTimeout(function(){xhr.onreadystatechange=empty,xhr.abort(),ajaxError(null,"timeout",xhr,settings)},settings.timeout)),xhr.send(settings.data?settings.data:null),xhr)},$.get=function(a,b){return $.ajax({url:a,success:b})},$.post=function(a,b,c,d){return $.isFunction(b)&&(d=d||c,c=b,b=null),$.ajax({type:"POST",url:a,data:b,success:c,dataType:d})},$.getJSON=function(a,b){return $.ajax({url:a,success:b,dataType:"json"})},$.fn.load=function(a,b){if(!this.length)return this;var c=this,d=a.split(/\s/),e;return d.length>1&&(a=d[0],e=d[1]),$.get(a,function(a){c.html(e?$(document.createElement("div")).html(a.replace(rscript,"")).find(e).html():a),b&&b.call(c)}),this};var escape=encodeURIComponent;$.param=function(a,b){var c=[];return c.add=function(a,b){this.push(escape(a)+"="+escape(b))},serialize(c,a,b),c.join("&").replace("%20","+")}}(Zepto),function(a){a.fn.serializeArray=function(){var b=[],c;return a(Array.prototype.slice.call(this.get(0).elements)).each(function(){c=a(this);var d=c.attr("type");this.nodeName.toLowerCase()!="fieldset"&&!this.disabled&&d!="submit"&&d!="reset"&&d!="button"&&(d!="radio"&&d!="checkbox"||this.checked)&&b.push({name:c.attr("name"),value:c.val()})}),b},a.fn.serialize=function(){var a=[];return this.serializeArray().forEach(function(b){a.push(encodeURIComponent(b.name)+"="+encodeURIComponent(b.value))}),a.join("&")},a.fn.submit=function(b){if(b)this.bind("submit",b);else if(this.length){var c=a.Event("submit");this.eq(0).trigger(c),c.defaultPrevented||this.get(0).submit()}return this}}(Zepto),function(a){function d(a){return"tagName"in a?a:a.parentNode}function e(a,b,c,d){var e=Math.abs(a-b),f=Math.abs(c-d);return e>=f?a-b>0?"Left":"Right":c-d>0?"Up":"Down"}function h(){g=null,b.last&&(b.el.trigger("longTap"),b={})}function i(){g&&clearTimeout(g),g=null}var b={},c,f=750,g;a(document).ready(function(){var j,k;a(document.body).bind("touchstart",function(e){j=Date.now(),k=j-(b.last||j),b.el=a(d(e.touches[0].target)),c&&clearTimeout(c),b.x1=e.touches[0].pageX,b.y1=e.touches[0].pageY,k>0&&k<=250&&(b.isDoubleTap=!0),b.last=j,g=setTimeout(h,f)}).bind("touchmove",function(a){i(),b.x2=a.touches[0].pageX,b.y2=a.touches[0].pageY}).bind("touchend",function(a){i(),b.isDoubleTap?(b.el.trigger("doubleTap"),b={}):b.x2&&Math.abs(b.x1-b.x2)>30||b.y2&&Math.abs(b.y1-b.y2)>30?(b.el.trigger("swipe")&&b.el.trigger("swipe"+e(b.x1,b.x2,b.y1,b.y2)),b={}):"last"in b&&(b.el.trigger("tap"),c=setTimeout(function(){c=null,b.el.trigger("singleTap"),b={}},250))}).bind("touchcancel",function(){c&&clearTimeout(c),g&&clearTimeout(g),g=c=null,b={}})}),["swipe","swipeLeft","swipeRight","swipeUp","swipeDown","doubleTap","tap","singleTap","longTap"].forEach(function(b){a.fn[b]=function(a){return this.bind(b,a)}})}(Zepto);


//     Backbone.js 1.0.0

//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `exports`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both the browser and the server.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.0.0';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    _.extend(this, _.pick(options, modelOptions));
    if (options.parse) attrs = this.parse(attrs, options) || {};
    if (defaults = _.result(this, 'defaults')) {
      attrs = _.defaults({}, attrs, defaults);
    }
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // A list of options to be attached directly to the model, if provided.
  var modelOptions = ['url', 'urlRoot', 'collection'];

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = true;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

      options = _.extend({validate: true}, options);

      // Do not persist invalid models.
      if (!this._validate(attrs, options)) return false;

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.url) this.url = options.url;
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, merge: false, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.defaults(options || {}, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      models = _.isArray(models) ? models.slice() : [models];
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults(options || {}, setOptions);
      if (options.parse) models = this.parse(models, options);
      if (!_.isArray(models)) models = models ? [models] : [];
      var i, l, model, attrs, existing, sort;
      var at = options.at;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        if (!(model = this._prepareModel(models[i], options))) continue;

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(model)) {
          if (options.remove) modelMap[existing.cid] = true;
          if (options.merge) {
            existing.set(model.attributes, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }

        // This is a new model, push it to the `toAdd` list.
        } else if (options.add) {
          toAdd.push(model);

          // Listen to added models' events, and index models for lookup by
          // `id` and by `cid`.
          model.on('all', this._onModelEvent, this);
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
        }
      }

      // Remove nonexistent models if appropriate.
      if (options.remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          splice.apply(this.models, [at, 0].concat(toAdd));
        } else {
          push.apply(this.models, toAdd);
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      if (options.silent) return this;

      // Trigger `add` events.
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }

      // Trigger `sort` if the collection was sorted.
      if (sort) this.trigger('sort', this, options);
      return this;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      options.previousModels = this.models;
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: this.length}, options));
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function(begin, end) {
      return this.models.slice(begin, end);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj.id != null ? obj.id : obj.cid || obj];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Figure out the smallest index at which a model should be inserted so as
    // to maintain order.
    sortedIndex: function(model, value, context) {
      value || (value = this.comparator);
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _.sortedIndex(this.models, model, iterator, context);
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options || (options = {});
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model._validate(attrs, options)) {
        this.trigger('invalid', this, attrs, options);
        return false;
      }
      return model;
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',
    'isEmpty', 'chain'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(e.g. model, collection, id, className)* are
    // attached directly to the view.  See `viewOptions` for an exhaustive
    // list.
    _configure: function(options) {
      if (this.options) options = _.extend({}, _.result(this, 'options'), options);
      _.extend(this, _.pick(options, viewOptions));
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && window.ActiveXObject &&
          !(window.external && window.external.msActiveXFilteringEnabled)) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        callback && callback.apply(router, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional){
                     return optional ? match : '([^\/]+)';
                   })
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param) {
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = this.location.pathname;
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        this.location.replace(this.root + this.location.search + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      fragment = this.getFragment(fragment || '');
      if (this.fragment === fragment) return;
      this.fragment = fragment;
      var url = this.root + fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function (model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

}).call(this);



/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false*/

(function (root, factory) {
  if (typeof exports === "object" && exports) {
    module.exports = factory; // CommonJS
  } else if (typeof define === "function" && define.amd) {
    define(factory); // AMD
  } else {
    root.Mustache = factory; // <script>
  }
}(this, (function () {

  var exports = {};

  exports.name = "mustache.js";
  exports.version = "0.7.2";
  exports.tags = ["{{", "}}"];

  exports.Scanner = Scanner;
  exports.Context = Context;
  exports.Writer = Writer;

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var nonSpaceRe = /\S/;
  var eqRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  function testRe(re, string) {
    return RegExp.prototype.test.call(re, string);
  }

  function isWhitespace(string) {
    return !testRe(nonSpaceRe, string);
  }

  var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };

  function escapeRe(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }

  var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': '&quot;',
    "'": '&#39;',
    "/": '&#x2F;'
  };

  function escapeHtml(string) {
    return String(string).replace(/[&<>"'\/]/g, function (s) {
      return entityMap[s];
    });
  }

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  exports.escape = escapeHtml;

  function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function () {
    return this.tail === "";
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function (re) {
    var match = this.tail.match(re);

    if (match && match.index === 0) {
      this.tail = this.tail.substring(match[0].length);
      this.pos += match[0].length;
      return match[0];
    }

    return "";
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function (re) {
    var match, pos = this.tail.search(re);

    switch (pos) {
    case -1:
      match = this.tail;
      this.pos += this.tail.length;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, pos);
      this.tail = this.tail.substring(pos);
      this.pos += pos;
    }

    return match;
  };

  function Context(view, parent) {
    this.view = view;
    this.parent = parent;
    this.clearCache();
  }

  Context.make = function (view) {
    return (view instanceof Context) ? view : new Context(view);
  };

  Context.prototype.clearCache = function () {
    this._cache = {};
  };

  Context.prototype.push = function (view) {
    return new Context(view, this);
  };

  Context.prototype.lookup = function (name) {
    var value = this._cache[name];

    if (!value) {
      if (name === ".") {
        value = this.view;
      } else {
        var context = this;

        while (context) {
          if (name.indexOf(".") > 0) {
            var names = name.split("."), i = 0;

            value = context.view;

            while (value && i < names.length) {
              value = value[names[i++]];
            }
          } else {
            value = context.view[name];
          }

          if (value != null) {
            break;
          }

          context = context.parent;
        }
      }

      this._cache[name] = value;
    }

    if (typeof value === "function") {
      value = value.call(this.view);
    }

    return value;
  };

  function Writer() {
    this.clearCache();
  }

  Writer.prototype.clearCache = function () {
    this._cache = {};
    this._partialCache = {};
  };

  Writer.prototype.compile = function (template, tags) {
    var fn = this._cache[template];

    if (!fn) {
      var tokens = exports.parse(template, tags);
      fn = this._cache[template] = this.compileTokens(tokens, template);
    }

    return fn;
  };

  Writer.prototype.compilePartial = function (name, template, tags) {
    var fn = this.compile(template, tags);
    this._partialCache[name] = fn;
    return fn;
  };

  Writer.prototype.compileTokens = function (tokens, template) {
    var fn = compileTokens(tokens);
    var self = this;

    return function (view, partials) {
      if (partials) {
        if (typeof partials === "function") {
          self._loadPartial = partials;
        } else {
          for (var name in partials) {
            self.compilePartial(name, partials[name]);
          }
        }
      }

      return fn(self, Context.make(view), template);
    };
  };

  Writer.prototype.render = function (template, view, partials) {
    return this.compile(template)(view, partials);
  };

  Writer.prototype._section = function (name, context, text, callback) {
    var value = context.lookup(name);

    switch (typeof value) {
    case "object":
      if (isArray(value)) {
        var buffer = "";

        for (var i = 0, len = value.length; i < len; ++i) {
          buffer += callback(this, context.push(value[i]));
        }

        return buffer;
      }

      return value ? callback(this, context.push(value)) : "";
    case "function":
      var self = this;
      var scopedRender = function (template) {
        return self.render(template, context);
      };

      var result = value.call(context.view, text, scopedRender);
      return result != null ? result : "";
    default:
      if (value) {
        return callback(this, context);
      }
    }

    return "";
  };

  Writer.prototype._inverted = function (name, context, callback) {
    var value = context.lookup(name);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0)) {
      return callback(this, context);
    }

    return "";
  };

  Writer.prototype._partial = function (name, context) {
    if (!(name in this._partialCache) && this._loadPartial) {
      this.compilePartial(name, this._loadPartial(name));
    }

    var fn = this._partialCache[name];

    return fn ? fn(context) : "";
  };

  Writer.prototype._name = function (name, context) {
    var value = context.lookup(name);

    if (typeof value === "function") {
      value = value.call(context.view);
    }

    return (value == null) ? "" : String(value);
  };

  Writer.prototype._escaped = function (name, context) {
    return exports.escape(this._name(name, context));
  };

  /**
   * Low-level function that compiles the given `tokens` into a function
   * that accepts three arguments: a Writer, a Context, and the template.
   */
  function compileTokens(tokens) {
    var subRenders = {};

    function subRender(i, tokens, template) {
      if (!subRenders[i]) {
        var fn = compileTokens(tokens);
        subRenders[i] = function (writer, context) {
          return fn(writer, context, template);
        };
      }

      return subRenders[i];
    }

    return function (writer, context, template) {
      var buffer = "";
      var token, sectionText;

      for (var i = 0, len = tokens.length; i < len; ++i) {
        token = tokens[i];

        switch (token[0]) {
        case "#":
          sectionText = template.slice(token[3], token[5]);
          buffer += writer._section(token[1], context, sectionText, subRender(i, token[4], template));
          break;
        case "^":
          buffer += writer._inverted(token[1], context, subRender(i, token[4], template));
          break;
        case ">":
          buffer += writer._partial(token[1], context);
          break;
        case "&":
          buffer += writer._name(token[1], context);
          break;
        case "name":
          buffer += writer._escaped(token[1], context);
          break;
        case "text":
          buffer += token[1];
          break;
        }
      }

      return buffer;
    };
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens(tokens) {
    var tree = [];
    var collector = tree;
    var sections = [];

    var token;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];
      switch (token[0]) {
      case '#':
      case '^':
        sections.push(token);
        collector.push(token);
        collector = token[4] = [];
        break;
      case '/':
        var section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;
        break;
      default:
        collector.push(token);
      }
    }

    return tree;
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens(tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];
      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        lastToken = token;
        squashedTokens.push(token);
      }
    }

    return squashedTokens;
  }

  function escapeTags(tags) {
    return [
      new RegExp(escapeRe(tags[0]) + "\\s*"),
      new RegExp("\\s*" + escapeRe(tags[1]))
    ];
  }

  /**
   * Breaks up the given `template` string into a tree of token objects. If
   * `tags` is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. ["<%", "%>"]). Of
   * course, the default is to use mustaches (i.e. Mustache.tags).
   */
  exports.parse = function (template, tags) {
    template = template || '';
    tags = tags || exports.tags;

    if (typeof tags === 'string') tags = tags.split(spaceRe);
    if (tags.length !== 2) {
      throw new Error('Invalid tags: ' + tags.join(', '));
    }

    var tagRes = escapeTags(tags);
    var scanner = new Scanner(template);

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace() {
      if (hasTag && !nonSpace) {
        while (spaces.length) {
          tokens.splice(spaces.pop(), 1);
        }
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var start, type, value, chr;
    while (!scanner.eos()) {
      start = scanner.pos;
      value = scanner.scanUntil(tagRes[0]);

      if (value) {
        for (var i = 0, len = value.length; i < len; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push(["text", chr, start, start + 1]);
          start += 1;

          if (chr === "\n") {
            stripSpace(); // Check for whitespace on the current line.
          }
        }
      }

      start = scanner.pos;

      // Match the opening tag.
      if (!scanner.scan(tagRes[0])) {
        break;
      }

      hasTag = true;
      type = scanner.scan(tagRe) || "name";

      // Skip any whitespace between tag and value.
      scanner.scan(whiteRe);

      // Extract the tag value.
      if (type === "=") {
        value = scanner.scanUntil(eqRe);
        scanner.scan(eqRe);
        scanner.scanUntil(tagRes[1]);
      } else if (type === "{") {
        var closeRe = new RegExp("\\s*" + escapeRe("}" + tags[1]));
        value = scanner.scanUntil(closeRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(tagRes[1]);
        type = "&";
      } else {
        value = scanner.scanUntil(tagRes[1]);
      }

      // Match the closing tag.
      if (!scanner.scan(tagRes[1])) {
        throw new Error('Unclosed tag at ' + scanner.pos);
      }

      // Check section nesting.
      if (type === '/') {
        if (sections.length === 0) {
          throw new Error('Unopened section "' + value + '" at ' + start);
        }

        var section = sections.pop();

        if (section[1] !== value) {
          throw new Error('Unclosed section "' + section[1] + '" at ' + start);
        }
      }

      var token = [type, value, start, scanner.pos];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === "name" || type === "{" || type === "&") {
        nonSpace = true;
      } else if (type === "=") {
        // Set the tags for the next time around.
        tags = value.split(spaceRe);

        if (tags.length !== 2) {
          throw new Error('Invalid tags at ' + start + ': ' + tags.join(', '));
        }

        tagRes = escapeTags(tags);
      }
    }

    // Make sure there are no open sections when we're done.
    var section = sections.pop();
    if (section) {
      throw new Error('Unclosed section "' + section[1] + '" at ' + scanner.pos);
    }

    return nestTokens(squashTokens(tokens));
  };

  // The high-level clearCache, compile, compilePartial, and render functions
  // use this default writer.
  var _writer = new Writer();

  /**
   * Clears all cached templates and partials in the default writer.
   */
  exports.clearCache = function () {
    return _writer.clearCache();
  };

  /**
   * Compiles the given `template` to a reusable function using the default
   * writer.
   */
  exports.compile = function (template, tags) {
    return _writer.compile(template, tags);
  };

  /**
   * Compiles the partial with the given `name` and `template` to a reusable
   * function using the default writer.
   */
  exports.compilePartial = function (name, template, tags) {
    return _writer.compilePartial(name, template, tags);
  };

  /**
   * Compiles the given array of tokens (the output of a parse) to a reusable
   * function using the default writer.
   */
  exports.compileTokens = function (tokens, template) {
    return _writer.compileTokens(tokens, template);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  exports.render = function (template, view, partials) {
    return _writer.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.
  exports.to_html = function (template, view, partials, send) {
    var result = exports.render(template, view, partials);

    if (typeof send === "function") {
      send(result);
    } else {
      return result;
    }
  };

  return exports;

}())));



var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-43186716-1']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = 'https://ssl.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();



// From http://arcturo.github.com/library/coffeescript/03_classes.html

var moduleKeywords,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

moduleKeywords = ['extended', 'included'];

Module = (function() {

  function Module() {}

  Module.extend = function(obj) {
    var key, value, _ref;
    for (key in obj) {
      value = obj[key];
      if (__indexOf.call(moduleKeywords, key) < 0) {
        this[key] = value;
      }
    }
    if ((_ref = obj.extended) != null) {
      _ref.apply(this);
    }
    return this;
  };

  Module.include = function(obj) {
    var key, value, _ref;
    for (key in obj) {
      value = obj[key];
      if (__indexOf.call(moduleKeywords, key) < 0) {
        this.prototype[key] = value;
      }
    }
    if ((_ref = obj.included) != null) {
      _ref.apply(this);
    }
    return this;
  };

  return Module;

})();

if(typeof(Backbone) != 'undefined') {
  Backbone.Model.include = Backbone.View.include = Backbone.Collection.include = Module.include;
}
BH.Base.include = Module.include;



BH.Templates.active_tags = "<ul class='tags'>  {{#tags}}    <li>      <a href='#tags/{{.}}' data-tag='{{.}}' class='tag'>{{.}}</a>      {{#editable}}        <a href='#' data-tag='{{.}}' class='delete'></a>      {{/editable}}    </li>  {{/tags}}</ul>{{^tags}}  <p class='no_tags'>    No tags found. Add one!  </p>{{/tags}}";

BH.Templates.app = "<div class='frame'>  <div class='mainview view'></div>  <div class='navigation'>    <h1>      <a href='#/'>        {{i18n_history_title}}      </a>    </h1>    <div class='available_tags'></div>    <ul class='menu'>      <li>        <a class='tags' href='#tags'>          {{i18n_tags_link}}          <span class='new'>New!</span>          <span class='syncing'></span>        </a>      </li>    </ul>    <div class='menu menu_view disappearable'></div>    <ul class='menu disappearable'>      <li>        <a class='setting' href='#settings'>          {{i18n_settings_link}}        </a>      </li>    </ul>  </div></div><div id='coverup'></div>";

BH.Templates.auth_error = "<h1 class='title'>{{i18n_auth_error_title}}</h1><div class='content-area'>  <p>{{i18n_auth_error_description}}</div><div class='action-area'>  <a href='#' class='cancel'>{{i18n_prompt_cancel_button}}</a>  <div class='action-area-right'>    <div class='button-strip'>      <button class='login'>{{i18n_login_again_button}}</button>    </div>  </div></div>";

BH.Templates.autocomplete_tags = "<div class='autocomplete_shell'>  <div class='active_tags'></div>  <input autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' type='text' class='new_tag' placeholder='{{i18n_add_a_tag_placeholder}}'/></div><div class='suggestions'></div><div class='syncing'></div>";

BH.Templates.available_tags = "<ul class='tags'>  <li class='new_tag'>&#43; New tag</li>  {{#tags}}    <li data-tag='{{name}}' class='{{#tagged}}tagged{{/tagged}}'>      {{name}}    </li>  {{/tags}}</ul>";

BH.Templates.connection_required = "<h1 class='title'>{{i18n_connection_required_title}}</h1><div class='content-area'>  <div class='warning'>&#x26a0;</div>  {{i18n_connection_required_description}}</div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='okay'>{{i18n_prompt_okay_button}}</button>    </div>  </div></div>";

BH.Templates.connection_restored = "<h1 class='title'>{{i18n_connection_restored_title}}</h1><div class='content-area'>  <span class='successful_sync'>&#x2713;</span>  {{i18n_connection_restored_description}}</div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='okay'>{{i18n_prompt_okay_button}}</button>    </div>  </div></div>";

BH.Templates.credits = "<img class='logo' src='/images/medium_logo.png' /><h1 class='title'>{{i18n_credits_title}}</h1><div class='content-area'>  <div>{{{i18n_developed_by}}}</div>  <h3>Open source frameworks in use</h3>  <ul class='open_source'>    <li>      <a href='http://backbonejs.org/'>Backbone</a>    </li>    <li>      <a href='http://documentcloud.github.com/underscore/'>Underscore</a>    </li>    <li>      <a href='http://zeptojs.com/'>Zepto</a>    </li>    <li>      <a href='https://github.com/janl/mustache.js/'>Mustache.js</a>    </li>    <li>      <a href='http://momentjs.com/'>Moment.js</a>    </li>    <li>      <a href='https://github.com/roykolak/chrome-bootstrap'>Chrome Bootstrap</a>    </li>  </ul>  <h3>{{i18n_translators_heading}}</h3>  <div>    <ul class='translators'>      <li>        <a href='http://twitter.com/laucmar'>Laura Martínez</a>        <div class='language'>{{i18n_spanish}}</div>      </li>      <li>        <a href='http://gplus.to/dfakhriev'>Damir Fakhriev</a>        <div class='language'>{{i18n_russian}}</div>      </li>      <li>        <a href='https://plus.google.com/115314774787477379472'>Filipe Catalão</a>        <div class='language'>{{i18n_portuguese}}</div>      </li>      <li>        <a href='http://theopenspring.com'>Gianluca Sangiovanni</a>        <div class='language'>{{i18n_italian}}</div>      </li>      <li>        <a href='mailto:tebai.hamza@gmail.com'>Hamza Tebai</a>        <div class='language'>{{i18n_french}}</div>      </li>      <li>        <a href='http://about.me/henrikcederblad'>Henrik Cederblad</a>        <div class='language'>{{i18n_swedish}}</div>      </li>      <li>        <a href='https://plus.google.com/u/0/115959812130668207635/posts'>PBB</a>        <div class='language'>{{i18n_chinese_simplified}}</div>      </li>    </ul>    <ul class='translators'>      <li>        <a href='http://twitter.com/kurtextrem'>Jacob G</a>        <div class='language'>{{i18n_german}}</div>      </li>      <li>        <a href='http://www.jedlikowski.com'>Przemek Jedlikowski</a>        <div class='language'>{{i18n_polish}}</div>      </li>      <li>        <a href='https://twitter.com/yl_ksa'>Wael M. Hazzazi</a>        <div class='language'>{{i18n_arabic}}</div>      </li>      <li>        <a href='http://twitter.com/HowManyFiles'>ハウメニ</a>        <div class='language'>{{i18n_japanese}}</div>      </li>      <li>        <a href='http://facebook.com/khaister'>Khai Nguyen</a>        <div class='language'>{{i18n_vietnamese}}</div>      </li>      <li>        Juanjo Teruel        <div class='language'>{{i18n_catalonian}}</div>      </li>    </ul>  </div>  <h4>{{i18n_translation_help_heading}}</h4>  <p style='width:auto'>{{{i18n_translation_instructions}}}</p></div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='button close'>{{i18n_close_button}}</button>    </div>  </div></div>";

BH.Templates.day = "<header>  <h1 class='title'>    {{{title}}}    <span class='sub_title'>{{formalDate}}</span>  </h1>  <div class='corner'>    <input class='search' placeholder='{{i18n_search_input_placeholder_text}}' tabindex='1' type='text' />  </div>  <div class='controls'>    <div class='spinner'></div>    <a class='text back_to_week' href='{{weekUrl}}'>      {{{i18n_back_to_week_link}}}    </a>    <div class='spacer'></div>    <button class='delete_day' disabled='disabled'>      {{i18n_delete_all_visits_for_filter_button}}    </button>  </div></header><div class='content'></div>";

BH.Templates.day_results = "<ol class='history'>  {{#history}}    <li class='interval' data-id='{{id}}'>      <header>        <h4 class='title'>{{time}}</h4>        <a class='delete_interval delete' href='#' title='{{i18n_prompt_delete_button}}'>          {{i18n_prompt_delete_button}}        </a>      </header>      <ol class='visits highlightable editable'>        {{#visits}}          {{#isGrouped}}            <li class='visit grouped_sites' draggable='true' data-domain='{{domain}}'>              {{^readOnly}}                <div class='drag_handle'>                  <div class='line'></div>                  <div class='line'></div>                  <div class='line'></div>                  <div class='line'></div>                  <div class='line'></div>                </div>              {{/readOnly}}              <a href='{{url}}' class='sites'>                <dl class='description' style='background-image: url(chrome://favicon/{{url}})'>                  <dt>                    <div class='active_tags'></div>                    {{domain}}                  </dt>                  <dd class='time'>{{time}}</dd>                  <dd class='toggle_grouping'>                    <span class='show_visits'>                      <span class='arrow arrow_collapse'></span>                      {{i18n_expand_button}}                    </span>                    <span class='hide_visits'>                      <span class='arrow arrow_expand'></span>                      {{i18n_collapse_button}}                    </span>                  </dd>                </dl>              </a>              <a class='search_domain action' href='#search/{{host}}'>{{i18n_search_by_domain}}</a>              <a class='delete_grouped_visit delete' href='#' title='{{i18n_prompt_delete_button}}'>{{i18n_prompt_delete_button}}</a>              <ol class='visits highlightable'>                {{#groupedVisits}}                  <li class='visit' draggable='true' data-url='{{url}}' data-title='{{title}}'>                    {{^readOnly}}                      <div class='drag_handle'>                        <div class='line'></div>                        <div class='line'></div>                        <div class='line'></div>                        <div class='line'></div>                        <div class='line'></div>                      </div>                    {{/readOnly}}                    <a href='{{url}}' class='site'>                      <dl class='description' style='background-image: url(chrome://favicon/{{url}})'>                        <dt>                          <div class='active_tags'></div>                          {{{title}}}                        </dt>                        <dd class='time'>{{time}}</dd>                        <dd class='location'>{{host}}{{path}}</dd>                      </dl>                    </a>                    <a class='search_domain action' href='#search/{{host}}'>{{i18n_search_by_domain}}</a>                    <a class='delete_visit delete' href='#' data-url='{{url}}' title='{{i18n_prompt_delete_button}}'>{{i18n_prompt_delete_button}}</a>                  </li>                {{/groupedVisits}}              </ol>            </li>          {{/isGrouped}}          {{^isGrouped}}            <li class='visit' draggable='true' data-url='{{url}}' data-title='{{title}}'>              {{^readOnly}}                <div class='drag_handle'>                  <div class='line'></div>                  <div class='line'></div>                  <div class='line'></div>                  <div class='line'></div>                  <div class='line'></div>                </div>              {{/readOnly}}              <a href='{{url}}' class='site'>                <dl class='description' style='background-image: url(chrome://favicon/{{url}})'>                  <dt>                    <div class='active_tags'></div>                    {{{title}}}                  </dt>                  <dd class='time'>{{time}}</dd>                  <dd class='location'>{{host}}{{path}}</dd>                </dl>              </a>              <a class='search_domain action' href='#search/{{host}}'>{{i18n_search_by_domain}}</a>              <a class='delete_visit delete' href='#' data-url='{{url}}' title='{{i18n_prompt_delete_button}}'>{{i18n_prompt_delete_button}}</a>            </li>          {{/isGrouped}}        {{/visits}}      </ol>    </li>  {{/history}}</ol>{{^history}}  <p>{{i18n_no_visits_found}}</p>{{/history}}";

BH.Templates.how_to_tag = "<h1 class='title'>{{i18n_how_to_tag_title}}</h1><div class='content-area'>  <iframe name='quickcast' src='http://quick.as/embed/majubd4' scrolling='no' frameborder='0' width='100%' allowfullscreen></iframe></div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='done'>{{i18n_prompt_done_button}}</button>    </div>  </div></div>";

BH.Templates.initial_syncing = "<h1 class='title'>{{i18n_initial_syncing_title}}</h1><div class='content-area'>  <div class='syncing'>    <div class='spinner'></div>    <p>{{i18n_initial_syncing_description}}</p>  </div>  <div class='done_syncing' style='display: none;'>    <span class='successful_sync'>&#x2713;</span>    <p>{{{i18n_initial_syncing_done}}}</p>  </div></div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button disabled class='continue'>{{i18n_continue_button}}</button>    </div>  </div></div>";

BH.Templates.login_error = "<h1 class='title'>{{i18n_login_error_title}}</h1><div class='content-area'>  <div class='warning'>&#x26a0;</div>  {{i18n_login_error_description}}</div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='okay'>{{i18n_prompt_okay_button}}</button>    </div>  </div></div>";

BH.Templates.mailing_list = "<img class='logo' src='/images/medium_logo.png' /><h1 class='title'>{{i18n_mailing_list_title}}</h1><div class='content-area'>  <p>{{i18n_mailing_list_description}}</p>  <a href='http://mad.ly/signups/84938/join' target='_blank' id='join_mailing_list'>{{i18n_mailing_list_link}}</a>  <p><i>{{i18n_mailing_list_promise}}</i></p></div><div class='action-area'>  <a href='#'>{{i18n_leave_a_review}}</a>  <div class='action-area-right'>    <div class='button-strip'>      <button class='button close'>{{i18n_close_button}}</button>    </div>  </div></div>";

BH.Templates.menu = "<ul class='menu'>  {{#weeks}}    <li class='week' data-week-id='{{id}}'>      <a href='{{url}}'>        {{{shortTitle}}}      </a>    </li>  {{/weeks}}  <!--  <li class='all_weeks'>    <a href='#weeks'>      {{i18n_all_weeks_link}}    </a>  </li>  --></ul>";

BH.Templates.modal = "<div class='overlay transparent' id='overlay'>  <div class='page'></div></div>";

BH.Templates.new_tag = "<h1 class='title'>{{i18n_create_new_tag_title}}</h1><div class='content-area'>  <input class='new_tag' type='text' placeholder='{{i18n_new_tag_placeholder}}' /></div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='cancel no'>{{i18n_prompt_cancel_button}}</button>      <button class='rename yes'>{{i18n_new_tag_button}}</button>    </div>  </div></div>";

BH.Templates.prompt = "<div class='spinner'></div><h1 class='title'>{{i18n_prompt_title}}</h1><div class='content-area'>{{{content}}}</div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='no'>{{i18n_prompt_cancel_button}}</button>      <button class='yes'>{{i18n_prompt_delete_button}}</button>    </div>  </div></div>";

BH.Templates.read_only_explanation = "<h1 class='title'>{{i18n_read_only_explanation_title}}</h1><div class='content-area'>  {{i18n_read_only_explanation_description}}</div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='okay'>{{i18n_prompt_okay_button}}</button>    </div>  </div></div>";

BH.Templates.rename_tag = "<h1 class='title'>{{i18n_rename_tag_title}}</h1><div class='content-area'>  <input class='new_tag' type='text' placeholder='{{i18n_new_tag_placeholder}}' /></div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='cancel no'>{{i18n_prompt_cancel_button}}</button>      <button class='rename yes'>{{i18n_rename_tag_button}}</button>    </div>  </div></div>";

BH.Templates.search = "<header>  <h1>    <span class='title'>{{title}}</span>  </h1>  <div class='corner'>    <a href='#' class='delete'>cancel</a>    <input class='search' placeholder='{{i18n_search_input_placeholder_text}}' tabindex='1' type='text' />  </div>  <div class='controls'>    <div class='spinner'></div>    <div class='pagination' style='margin: 0; position: relative;'></div>    <div class='spacer'></div>    <button class='delete_all'>      {{i18n_delete_all_visits_for_search_button}}    </button>  </div></header><div class='fade'></div><div class='cached' style='display: none'>  Showing results from <span class='datetime'>DATE</span>.  <a class='fresh_search'>Freshen search</a></div><div class='content'></div>";

BH.Templates.search_pagination = "<ol class='pagination {{paginationClass}}'>  {{#pages}}    <li>      <a href='{{url}}' data-page='{{number}}' class='{{className}}'>{{number}}</a>    </li>  {{/pages}}</ol><div class='number_of_visits'>{{i18n_number_of_visits}}</div>";

BH.Templates.search_results = "<ol class='visits highlightable editable'>  {{#visits}}    <li class='visit visit_view searched' draggable='true' data-url='{{url}}' data-title='{{title}}'>      <div class='drag_handle'>        <div class='line'></div>        <div class='line'></div>        <div class='line'></div>        <div class='line'></div>        <div class='line'></div>      </div>      <a href='{{url}}' class='site'>        <dl class='description' style='background-image: url(chrome://favicon/{{url}})'>          <dt>            <div class='active_tags'></div>            {{{name}}}          </dt>          <dd class='location'>{{{location}}}</dd>          <dd>{{{time}}} | {{{extendedDate}}}</dd>        </dl>      </a>      <a class='delete_visit delete' href='#' data-url='{{url}}' title='{{i18n_prompt_delete_button}}'>{{i18n_prompt_delete_button}}</a>    </li>  {{/visits}}</ol>{{^visits}}  <p class='no_visits'>{{i18n_no_visits_found}}</p>{{/visits}}";

BH.Templates.server_error = "<h1 class='title'>{{i18n_server_error_title}}</h1><div class='content-area'>  <div class='warning'>&#x26a0;</div>  {{i18n_server_error_description}}</div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button class='okay'>{{i18n_prompt_okay_button}}</button>    </div>  </div></div>";

BH.Templates.settings = "<header>  <h1>{{i18n_settings_title}}</h1></header><div class='content'>  <div class='settings'>    <section>    <h3>{{i18n_syncing_settings_title}}</h3>      <div class='logged_out'>        <p>{{{i18n_syncing_settings_login}}}</p>        <div class='login_spinner small_spinner'></div>      </div>      <div class='logged_in'>        <img class='avatar' src='{{avatar}}' />        <p class='name'></p>        <a style='margin-right: 5px;'href='#' class='logout'>Logout</a> |        <a style='margin-left: 5px;' href='http://www.better-history.com/me'>better-history.com/me</a>        <div>          <a href='#' class='manually_sync_local'>{{i18n_manually_sync_local_link}}</a>        </div>      </div>    </section>    <section>      <h3>{{i18n_clearing_history_section_title}}</h3>      <div>        <button class='clear_history'>{{i18n_clear_history_button}}</button>      </div>    </section>    <section>      <h3>{{i18n_general_section_title}}</h3>      <div class='row'>        <label>          <span class='select'>{{i18n_open_location}}</span>          <select id='open_location'>            {{#openLocations}}              <option value='{{value}}'>{{text}}</option>            {{/openLocations}}          </select>        </label>      </div>      <div class='row'>        <label>          <span class='select'>{{i18n_starting_week_day}}</span>          <select id='starting_week_day'>            {{#startingWeekDays}}              <option value='{{value}}'>{{text}}</option>            {{/startingWeekDays}}          </select>        </label>      </div>      <div class='row'>        <label>          <span class='select'>{{i18n_week_day_order}}</span>          <select id='week_day_order'>            {{#weekDayOrders}}              <option value='{{value}}'>{{text}}</option>            {{/weekDayOrders}}          </select>        </label>      </div>    </section>    <section>      <h3>{{i18n_visit_grouping_section_title}}</h3>      <div class='row'>        <label>          <span class='select'>{{i18n_group_visits_by_label}}</span>          <select id='time_grouping'>            {{#timeGroupings}}              <option value='{{value}}'>{{text}}</option>            {{/timeGroupings}}          </select>        </label>      </div>      <div class='checkbox'>        <label>          <input id='domain_grouping' type='checkbox' />          <span>{{i18n_group_visits_by_domain_label}}</span>        </label>      </div>    </section>    <section>      <h3>{{i18n_right_click_options_section_title}}</h3>      <div class='checkbox'>        <label>          <input id='search_by_selection' type='checkbox' />          <span>{{i18n_search_by_text_selection_label}}</span>        </label>      </div>      <div class='checkbox'>        <label>          <input id='search_by_domain' type='checkbox' />          <span>{{i18n_search_by_domain_label}}</span>        </label>      </div>    </section>    <section>      <h3>{{i18n_whats_new_section_title}}</h3>      <div>        <div class='row'>          <a class='modal_link credits' href='#settings/credits'>{{{i18n_credits_link}}}</a>        </div>        <div class='row'>          {{{i18n_permissions_details}}}        </div>      </div>    </section>    <section>      <h3>{{i18n_feedback_section_title}}</h3>      <div>        {{{i18n_suggestions_bugs_comments}}}        <br />        <a style='margin-top: 10px; display: block;' href='mailto:hello@better-history.com'>hello@better-history.com</a>      </div>    </section>    <section>      <h3>{{i18n_spread_the_word_section_title}}</h3>      <div>        <div class='row'>          <a href='http://mad.ly/signups/84938/join' target='_blank'>{{i18n_mailing_list_link}}</a>        </div>        <div class='row'>          <a href='https://chrome.google.com/webstore/detail/obciceimmggglbmelaidpjlmodcebijb/reviews'>{{i18n_leave_a_review}}</a>        </div>        <div class='row'>          <!-- Place this tag where you want the +1 button to render -->          <div class='g-plusone' data-annotation='inline' data-href='https://chrome.google.com/webstore/detail/obciceimmggglbmelaidpjlmodcebijb'></div>        </div>        <div class='row'>          <a class='twitter-follow-button' data-lang='{{i18n_twitter_language}}' data-show-count='false' data-width='150px' href='https://twitter.com/better_history'>Follow @better_history</a>          <a class='twitter-share-button' data-count='horizontal' data-lang='{{i18n_twitter_language}}' data-text='{{i18n_twitter_template}}' data-url='https://chrome.google.com/webstore/detail/obciceimmggglbmelaidpjlmodcebijb' data-via='Better_History' href='https://twitter.com/share'>Tweet</a>        </div>      </div>    </section>  </div></div>";

BH.Templates.sign_up_info = "<img class='logo' src='/images/medium_logo.png' /><h1 class='title'>{{i18n_sign_up_info_title}}</h1><div class='content-area'>  <p>{{i18n_sign_up_info_description}}</p>  {{{i18n_sign_up_info_bullets}}}  <p class='price'>{{i18n_sign_up_info_price}}</p></div><div class='action-area'>  <p class='question'>{{i18n_sign_up_info_question}}</p>  <a href='#' class='cancel'>{{i18n_prompt_cancel_button}}</a>  <div class='action-area-right'>    <div class='button-strip'>      <button class='continue yes'>{{i18n_continue_button}}</button>    </div>  </div></div>";

BH.Templates.suggestions = "<ul>  {{#tags}}    <li data-tag='{{.}}'>{{.}}</li>  {{/tags}}</ul>";

BH.Templates.syncing_decision = "<h1 class='title'>{{i18n_syncing_decision_title}}</h1><div class='content-area'>  <div class='decision'>    <p>{{{i18n_syncing_decision_description}}}</p>    <div class='decision_options'>      <button class='pull'>{{i18n_syncing_pull_button}}</button>      - or -      <button class='push'>{{i18n_syncing_push_button}}</button>    </div>  </div>  <div class='syncing' style='display: none;'>    <div class='spinner'></div>    <p>{{i18n_initial_syncing_description}}</p>  </div>  <div class='done_syncing' style='display: none;'>    <span class='successful_sync'>&#x2713;</span>    <p>{{{i18n_initial_syncing_done}}}</p>  </div></div><div class='action-area'>  <div class='action-area-right'>    <div class='button-strip'>      <button style='display: none' class='continue'>{{i18n_continue_button}}</button>    </div>  </div></div>";

BH.Templates.tag = "<header>  <h1>{{i18n_tag_title}}</h1>  <div class='corner'>    <input class='search' placeholder='{{i18n_search_input_placeholder_text}}' tabindex='1' type='text' />  </div>  <div class='controls'>    <a class='text back_to_tags' href='{{tagsUrl}}'>      {{{i18n_back_to_tags_link}}}    </a>    <div class='spacer'></div>    <div class='small_spinner'></div>    {{#readOnly}}      <a class='text read_only_explanation'>        {{i18n_read_only_explanation_link}}      </a>    {{/readOnly}}    {{^readOnly}}      <a class='text share'>        {{i18n_share_tag_link}}      </a>      <a class='text rename'>        {{i18n_rename_tag_link}}      </a>      <button class='delete_sites'>        {{i18n_delete_tag}}      </button>    {{/readOnly}}  </div></header><div class='content'></div>";

BH.Templates.tagged_sites = "<ul class='visits highlightable editable'>  {{#sites}}  <li class='visit tagged' draggable='true' data-url='{{url}}' data-title='{{title}}'>      {{^readOnly}}        <div class='drag_handle'>          <div class='line'></div>          <div class='line'></div>          <div class='line'></div>          <div class='line'></div>          <div class='line'></div>        </div>      {{/readOnly}}      <a href='{{url}}' class='site'>        <dl class='description' style='background-image: url(chrome://favicon/{{url}})'>          <dt>            <div class='active_tags'></div>            {{title}}          </dt>          <dd>{{url}}</dd>        </dl>      </a>      {{^readOnly}}        <a class='delete' href='{{url}}' title=''></a>      {{/readOnly}}    </li>  {{/sites}}</ul>{{^sites}}  <p class='no_results'>{{i18n_no_tagged_sites_found}}</p>{{/sites}}";

BH.Templates.tagging = "<div class='container'>  <div class='header' style='background-image: url(chrome://favicon/{{url}})'>    <h1 class='scroll'>{{title}}</h1>    <div class='url scroll'>{{url}}</div>  </div>  {{^readOnly}}    <p class='about_tags alert'>      <a href='#' class='delete dismiss_instructions'></a>      {{{i18n_about_tags_for_popup}}}    </p>    <div class='autocomplete'></div>  {{/readOnly}}  <p class='shortcut'>{{shortcut}}</p></div><ul class='links'>  <li style='position: relative'>    <a id='explore_tags' href='chrome://history/#tags'>      {{i18n_explore_tags_link}}    </a>    {{#loggedIn}}      <div class='syncing_badge'>sync <span class='inline-tag'>ON</span></div>    {{/loggedIn}}  </li>  <li>    <a id='search_domain' href='chrome://history/#search/{{domain}}'>      {{i18n_search_domain_history_link}}    </a>  </li>  <li>    <a id='view_history' href='chrome://history/#today'>      {{i18n_view_all_history_link}}    </a>  </li></div>";

BH.Templates.tags = "<header>  <h1>{{i18n_tags_title}}</h1>  <div class='corner'>    <input class='search' placeholder='{{i18n_search_input_placeholder_text}}' tabindex='1' type='text' />  </div>  <div class='controls'>    <span class='text sync_enabled' {{#loggedIn}} style='display: block;'{{/loggedIn}}>{{{i18n_sync_enabled}}}</span>    <span class='text tag_count' style='display: none'>{{i18n_number_of_tags}}</span>    <span class='text sync_promo' {{#loggedIn}} style='display: none;'{{/loggedIn}}>{{{i18n_sync_tags_link}}}</span>    <div class='login_spinner small_spinner'></div>    <div class='spacer'></div>    {{#readOnly}}      <a class='text read_only_explanation'>        {{i18n_read_only_explanation_link}}      </a>    {{/readOnly}}    {{^readOnly}}      <a class='text how_to_tag'>        {{i18n_how_to_tag}}      </a>      <button class='delete_all'>        {{i18n_delete_all_tags}}      </button>    {{/readOnly}}  </div></header><div class='content'></div>";

BH.Templates.tags_list = "<p class='alert about_tags'>  <a href='#' class='delete dismiss_instructions'></a>  <strong>{{i18n_about_tags_title}}</strong>  {{{i18n_about_tags_instructions}}}</p><ul class='tag_list'>  {{#tags}}    <li>      <a href='#tags/{{name}}'>        <h3 class='title'>{{name}}</h3>        <div class='details'>          <ul class='favicons'>            {{#sites}}            <li>              <div class='favicon' style='background-image: url(chrome://favicon/{{url}})'></div>            </li>            {{/sites}}          </ul>        </div>      </a>    </li>  {{/tags}}</ul>{{^tags}}  <p class='no_results'>{{i18n_no_tags_found}}</p>  <p class='extra_help'>{{{i18n_extra_tag_help}}}</p>{{/tags}}";

BH.Templates.week = "<header>  <h1>{{{title}}}</h1>  <div class='corner'>    <input class='search' placeholder='{{i18n_search_input_placeholder_text}}' tabindex='1' type='text' />  </div>  <div class='controls'>    <span class='text count'></span>    <div class='spinner'></div>    <div class='spacer'></div>    <button class='delete_all'>      {{i18n_delete_all_visits_for_filter_button}}    </button>  </div></header><div class='content'>  <ol class='days'>    {{#days}}      <li class='day {{#inFuture}}future{{/inFuture}}' data-day='{{day}}'>        <a href='{{url}}'>          <div class='label'>            <h3 class='title'>{{title}}</h3>            <div class='count'></div>          </div>          <div class='bar_container'>            <div class='bar'></div>          </div>        </a>      </li>    {{/days}}  </ol></div><div class='day_views'></div>";

BH.Templates.weeks = "<header>  <h1>{{i18n_all_weeks_title}}</h1>  <div class='corner'>    <input class='search' placeholder='{{i18n_search_input_placeholder_text}}' tabindex='1' type='text' />  </div>  <div class='controls'>    <span class='text count'></span>    <div class='spinner'></div>    <div class='spacer'></div>    <button class='delete_all'>      {{i18n_delete_all_weeks_button}}    </button>  </div></header><div class='content'></div>";

BH.Templates.weeks_results = "<ol class='all_weeks'>  {{#weeks}}    <li>    <a href='{{url}}'>        <h3>{{shortTitle}}</h3>        <div class='details'>          {{visitCount}} visits        </div>      </a>    </li>  {{/weeks}}</ol>";




// Generated by CoffeeScript 1.6.1
(function() {

  BH.Trackers.ErrorTracker = (function() {

    ErrorTracker.prototype.key = "eb2245d5729a3c65d7e429f4e7690a62";

    ErrorTracker.prototype.version = "2.4.0";

    ErrorTracker.prototype.environment = "production";

    function ErrorTracker(tracker) {
      this.tracker = tracker;
      this.tracker.setContext({
        version: this.version
      });
      this.tracker.configure({
        api_key: this.key,
        environment: this.environment,
        onerror: true
      });
    }

    ErrorTracker.prototype.report = function(e, data) {
      if (data == null) {
        data = {};
      }
      return this.tracker.notify(e, {
        context: data
      });
    };

    return ErrorTracker;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Trackers.AnalyticsTracker = (function() {

    function AnalyticsTracker() {
      if (typeof _gaq === "undefined" || _gaq === null) {
        throw "Analytics not set";
      }
    }

    AnalyticsTracker.prototype.trackEvent = function(params) {
      params.unshift('_trackEvent');
      return this.track(params);
    };

    AnalyticsTracker.prototype.pageView = function(url) {
      if (url.match(/search/)) {
        url = 'search';
      }
      return this.track(['_trackPageview', "/" + url]);
    };

    AnalyticsTracker.prototype.track = function(params) {
      return _gaq.push(params);
    };

    AnalyticsTracker.prototype.historyOpen = function() {
      return this.trackEvent(['History', 'Open']);
    };

    AnalyticsTracker.prototype.weekView = function(date, distanceFromCurrentWeek) {
      return this.trackEvent(['Weeks', 'Click', date, distanceFromCurrentWeek]);
    };

    AnalyticsTracker.prototype.visitDeletion = function() {
      return this.trackEvent(['Visit', 'Delete']);
    };

    AnalyticsTracker.prototype.groupedVisitsDeletion = function() {
      return this.trackEvent(['Grouped visits', 'Delete']);
    };

    AnalyticsTracker.prototype.timeIntervalDeletion = function() {
      return this.trackEvent(['Time interval', 'Delete']);
    };

    AnalyticsTracker.prototype.dayVisitsDeletion = function() {
      return this.trackEvent(['Day visits', 'Delete']);
    };

    AnalyticsTracker.prototype.weekVisitsDeletion = function() {
      return this.trackEvent(['Week visits', 'Delete']);
    };

    AnalyticsTracker.prototype.searchResultsDeletion = function() {
      return this.trackEvent(['Search results', 'Delete']);
    };

    AnalyticsTracker.prototype.paginationClick = function() {
      return this.trackEvent(['Pagination', 'Click']);
    };

    AnalyticsTracker.prototype.omniboxSearch = function() {
      return this.trackEvent(['Omnibox', 'Search']);
    };

    AnalyticsTracker.prototype.contextMenuClick = function() {
      return this.trackEvent(['Context menu', 'Click']);
    };

    AnalyticsTracker.prototype.selectionContextMenuClick = function() {
      return this.trackEvent(['Selection context menu', 'Click']);
    };

    AnalyticsTracker.prototype.syncStorageError = function(operation, msg) {
      return this.trackEvent(['Storage Error', operation, 'Sync', msg]);
    };

    AnalyticsTracker.prototype.syncStorageAccess = function(operation) {
      return this.trackEvent(['Storage Access', operation, 'Sync']);
    };

    AnalyticsTracker.prototype.localStorageError = function(operation, msg) {
      return this.trackEvent(['Storage Error', operation, 'Local', msg]);
    };

    AnalyticsTracker.prototype.mailingListPrompt = function() {
      return this.trackEvent(['Mailing List Prompt', 'Seen']);
    };

    AnalyticsTracker.prototype.popupVisible = function() {
      return this.trackEvent(['Popup', 'Seen']);
    };

    AnalyticsTracker.prototype.exploreTagsPopupClick = function() {
      return this.trackEvent(['Popup', 'Explore Tags Click']);
    };

    AnalyticsTracker.prototype.searchByDomainPopupClick = function() {
      return this.trackEvent(['Popup', 'Search by Domain Click']);
    };

    AnalyticsTracker.prototype.tagDetailsPopupClick = function() {
      return this.trackEvent(['Popup', 'Tag Details Click']);
    };

    AnalyticsTracker.prototype.viewAllHistoryPopupClick = function() {
      return this.trackEvent(['Popup', 'View all History Click']);
    };

    AnalyticsTracker.prototype.howToTagClick = function() {
      return this.trackEvent(['Tags', 'How to Tag Click']);
    };

    AnalyticsTracker.prototype.deleteAllTagsClick = function() {
      return this.trackEvent(['Tags', 'Delete all Click']);
    };

    AnalyticsTracker.prototype.siteTagDrag = function() {
      return this.trackEvent(['Tag', 'Site Drag']);
    };

    AnalyticsTracker.prototype.siteTagDrop = function() {
      return this.trackEvent(['Tag', 'Site Drop']);
    };

    AnalyticsTracker.prototype.renameTagClick = function() {
      return this.trackEvent(['Tag', 'Rename Click']);
    };

    AnalyticsTracker.prototype.deleteTagClick = function() {
      return this.trackEvent(['Tag', 'Delete Tag Click']);
    };

    AnalyticsTracker.prototype.tagAdded = function() {
      return this.trackEvent(['Tag', 'Added']);
    };

    AnalyticsTracker.prototype.tagRemoved = function() {
      return this.trackEvent(['Tag', 'Removed']);
    };

    AnalyticsTracker.prototype.tagRenamed = function() {
      return this.trackEvent(['Tag', 'Renamed']);
    };

    AnalyticsTracker.prototype.siteTagged = function() {
      return this.trackEvent(['Site', 'Tagged']);
    };

    AnalyticsTracker.prototype.siteUntagged = function() {
      return this.trackEvent(['Site', 'Untagged']);
    };

    AnalyticsTracker.prototype.shareClicked = function() {
      return this.trackEvent(['Tag', 'Shared']);
    };

    AnalyticsTracker.prototype.getStartedSyncingModalSeen = function() {
      return this.trackEvent(['Get Started Modal', 'Seen']);
    };

    AnalyticsTracker.prototype.getStartedSyncingContinueClicked = function() {
      return this.trackEvent(['Get Started Modal', 'Continue Click']);
    };

    AnalyticsTracker.prototype.getStartedSyncingCancelClicked = function() {
      return this.trackEvent(['Get Started Modal', 'Cancel Click']);
    };

    AnalyticsTracker.prototype.syncPurchaseSuccess = function() {
      return this.trackEvent(['Sync', 'Purchased', 'Success']);
    };

    AnalyticsTracker.prototype.syncPurchaseFailure = function() {
      return this.trackEvent(['Sync', 'Purchased', 'Failure']);
    };

    AnalyticsTracker.prototype.syncDecisionModalSeen = function() {
      return this.trackEvent(['Sync Decision Modal', 'Seen']);
    };

    AnalyticsTracker.prototype.syncAutomaticModalSeen = function() {
      return this.trackEvent(['Sync Automatic Modal', 'Seen']);
    };

    AnalyticsTracker.prototype.userLoggedIn = function() {
      return this.trackEvent(['User', 'Log In']);
    };

    AnalyticsTracker.prototype.userLoggedOut = function() {
      return this.trackEvent(['User', 'Log Out']);
    };

    AnalyticsTracker.prototype.userCreationFailure = function() {
      return this.trackEvent(['User', 'Creation', 'Failure']);
    };

    AnalyticsTracker.prototype.userCreationSuccess = function() {
      return this.trackEvent(['User', 'Creation', 'Success']);
    };

    AnalyticsTracker.prototype.userOAuthFailure = function() {
      return this.trackEvent(['User', 'OAuth', 'Failure']);
    };

    AnalyticsTracker.prototype.userOAuthSuccess = function() {
      return this.trackEvent(['User', 'OAuth', 'Success']);
    };

    AnalyticsTracker.prototype.ensureDatetimeOnTaggedSitesMigration = function() {
      return this.trackEvent(['Migration', 'ensure_datetime_on_tagged_sites']);
    };

    return AnalyticsTracker;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Chrome.LocalStore = (function() {

    function LocalStore(options) {
      if (options == null) {
        options = {};
      }
      if (options.chrome == null) {
        throw "Chrome API not set";
      }
      if (options.tracker == null) {
        throw "Tracker not set";
      }
      this.chromeAPI = options.chrome;
      this.tracker = options.tracker;
    }

    LocalStore.prototype.set = function(object, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.chromeAPI.storage.local.set(object, function(data) {
        return _this.wrappedCallback('Set', data, callback);
      });
    };

    LocalStore.prototype.remove = function(key, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.chromeAPI.storage.local.remove(key, function(data) {
        return _this.wrappedCallback('Remove', data, callback);
      });
    };

    LocalStore.prototype.clear = function() {
      return this.chromeAPI.storage.local.clear();
    };

    LocalStore.prototype.get = function(key, callback) {
      var _this = this;
      return this.chromeAPI.storage.local.get(key, function(data) {
        return _this.wrappedCallback('Get', data, callback);
      });
    };

    LocalStore.prototype.wrappedCallback = function(operation, data, callback) {
      var message, _ref;
      if (this.chromeAPI.runtime.lastError != null) {
        message = (_ref = this.chromeAPI.runtime.lastError) != null ? _ref.message : void 0;
        this.tracker.localStorageError(operation, message);
      }
      return callback(data);
    };

    return LocalStore;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Chrome.SyncStore = (function() {

    function SyncStore(options) {
      if (options == null) {
        options = {};
      }
      if (options.chrome == null) {
        throw "Chrome API not set";
      }
      if (options.tracker == null) {
        throw "Tracker not set";
      }
      this.chromeAPI = options.chrome;
      this.tracker = options.tracker;
    }

    SyncStore.prototype.set = function(object, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.chromeAPI.storage.sync.set(object, function(data) {
        return _this.wrappedCallback('Set', data, callback);
      });
    };

    SyncStore.prototype.remove = function(key, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.chromeAPI.storage.sync.remove(key, function(data) {
        return _this.wrappedCallback('Remove', data, callback);
      });
    };

    SyncStore.prototype.get = function(key, callback) {
      var _this = this;
      return this.chromeAPI.storage.sync.get(key, function(data) {
        return _this.wrappedCallback('Get', data, callback);
      });
    };

    SyncStore.prototype.wrappedCallback = function(operation, data, callback) {
      var message, _ref;
      if (data == null) {
        data = {};
      }
      if (this.chromeAPI.runtime.lastError != null) {
        message = (_ref = this.chromeAPI.runtime.lastError) != null ? _ref.message : void 0;
        this.tracker.syncStorageError(operation, message);
      } else {
        if (operation !== 'Get') {
          this.tracker.syncStorageAccess(operation);
        }
      }
      return callback(data);
    };

    return SyncStore;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Lib.ImageData = {
    base64: function(url, callback) {
      var img,
        _this = this;
      img = new Image();
      img.src = url;
      return img.onload = function() {
        var canvas, ctx, dataURL;
        canvas = document.createElement("canvas");
        ctx = canvas.getContext("2d");
        ctx.drawImage(img, 16, 16);
        dataURL = canvas.toDataURL("image/png");
        return callback(dataURL);
      };
    }
  };

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Lib.SyncingTranslator = (function() {

    function SyncingTranslator() {}

    SyncingTranslator.prototype.forServer = function(compiledTags, callback, options) {
      var foundIndex, index, requestImage, site, sites, storedSite, tag, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _results;
      if (options == null) {
        options = {};
      }
      sites = [];
      for (_i = 0, _len = compiledTags.length; _i < _len; _i++) {
        tag = compiledTags[_i];
        _ref = tag.sites;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          site = _ref[_j];
          if (site.url) {
            foundIndex = null;
            for (index = _k = 0, _len2 = sites.length; _k < _len2; index = ++_k) {
              storedSite = sites[index];
              if (storedSite.url === site.url) {
                foundIndex = index;
                break;
              }
            }
            if (foundIndex != null) {
              sites[foundIndex].tags.push(tag.name);
            } else {
              site.tags = [tag.name];
              sites.push(site);
            }
          }
        }
      }
      if (!options.skipImages) {
        index = 1;
        requestImage = function(site) {
          return BH.Lib.ImageData.base64("chrome://favicon/" + site.url, function(data) {
            site.image = data;
            if (index === sites.length) {
              return callback(sites);
            } else {
              return index++;
            }
          });
        };
        _results = [];
        for (_l = 0, _len3 = sites.length; _l < _len3; _l++) {
          site = sites[_l];
          _results.push(requestImage(site));
        }
        return _results;
      } else {
        return callback(sites);
      }
    };

    SyncingTranslator.prototype.addImageToSites = function(sites, callback) {
      var index, requestImage, site, _i, _len, _results;
      index = 1;
      requestImage = function(site) {
        return BH.Lib.ImageData.base64("chrome://favicon/" + site.url, function(data) {
          site.image = data;
          if (index === sites.length) {
            return callback(sites);
          } else {
            return index++;
          }
        });
      };
      _results = [];
      for (_i = 0, _len = sites.length; _i < _len; _i++) {
        site = sites[_i];
        _results.push(requestImage(site));
      }
      return _results;
    };

    SyncingTranslator.prototype.forLocal = function(sites) {
      var data, site, tag, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
      data = {
        tags: []
      };
      for (_i = 0, _len = sites.length; _i < _len; _i++) {
        site = sites[_i];
        _ref = site.tags;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          tag = _ref[_j];
          data.tags.push(tag);
        }
      }
      data.tags = _.uniq(data.tags);
      _ref1 = data.tags;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        tag = _ref1[_k];
        data[tag] = [];
      }
      for (_l = 0, _len3 = sites.length; _l < _len3; _l++) {
        site = sites[_l];
        if (site.datetime == null) {
          site.datetime = new Date().getTime();
        }
        _ref2 = site.tags;
        for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
          tag = _ref2[_m];
          data[tag].push({
            url: site.url,
            title: site.title,
            datetime: site.datetime
          });
        }
      }
      return data;
    };

    return SyncingTranslator;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Lib.Syncer = (function() {

    function Syncer() {}

    Syncer.prototype.updateIfNeeded = function(callback) {
      if (callback == null) {
        callback = function() {};
      }
      return persistence.remote().sitesHash(function(remoteData) {
        return persistence.tag().getSitesHash(function(localData) {
          if (remoteData.sitesHash !== localData.sitesHash) {
            return persistence.remote().getSites(function(sites) {
              var data, syncingTranslator;
              syncingTranslator = new BH.Lib.SyncingTranslator();
              data = syncingTranslator.forLocal(sites);
              return persistence.tag()["import"](data, function() {
                chrome.runtime.sendMessage({
                  action: 'calculate hash'
                });
                return callback();
              });
            });
          }
        });
      });
    };

    return Syncer;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Persistence.Tag = (function() {

    function Tag(options) {
      if (options.localStore == null) {
        throw "Localstore is not set";
      }
      this.localStore = options.localStore;
    }

    Tag.prototype.setSitesHash = function(sitesHash) {
      return this.localStore.set({
        sitesHash: sitesHash
      }, function() {});
    };

    Tag.prototype.getSitesHash = function(callback) {
      return this.localStore.get('sitesHash', function(data) {
        return callback(data);
      });
    };

    Tag.prototype.getCompletedMigrations = function(callback) {
      return this.localStore.get('completedMigrations', function(data) {
        return callback(data.completedMigrations || []);
      });
    };

    Tag.prototype.markMigrationAsComplete = function(name, callback) {
      var _this = this;
      return this.localStore.get('completedMigrations', function(data) {
        data.completedMigrations || (data.completedMigrations = []);
        data.completedMigrations.push(name);
        return _this.localStore.set(data, function() {
          return callback();
        });
      });
    };

    Tag.prototype.cached = function(callback) {
      return this.localStore.get(null, function(data) {
        return callback({
          siteTags: function(url) {
            var matches, result, tag, _i, _len, _ref;
            matches = [];
            _ref = data.tags;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              tag = _ref[_i];
              result = _.where(data[tag], {
                url: url
              });
              if (result.length > 0) {
                matches.push(tag);
              }
            }
            return matches;
          },
          sitesTags: function(urls) {
            var matches, result, siteTags, tag, url, _i, _j, _len, _len1, _ref;
            siteTags = [];
            for (_i = 0, _len = urls.length; _i < _len; _i++) {
              url = urls[_i];
              matches = [];
              _ref = data.tags;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                tag = _ref[_j];
                result = _.where(data[tag], {
                  url: url
                });
                if (result.length > 0) {
                  matches.push(tag);
                }
              }
              siteTags.push(matches);
            }
            return _.intersection.apply(this, siteTags);
          }
        });
      });
    };

    Tag.prototype.fetchTags = function(callback) {
      var _this = this;
      return this.localStore.get('tags', function(data) {
        var tags;
        tags = data.tags || [];
        return _this.localStore.get(tags, function(data) {
          var compiledTags, foundTags, sites, tag;
          foundTags = [];
          compiledTags = (function() {
            var _results;
            _results = [];
            for (tag in data) {
              sites = data[tag];
              _results.push({
                name: tag,
                sites: sites
              });
            }
            return _results;
          })();
          return callback(tags, compiledTags);
        });
      });
    };

    Tag.prototype.fetchTagSites = function(name, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.localStore.get(name, function(data) {
        var site, sites;
        data[name] || (data[name] = []);
        sites = (function() {
          var _i, _len, _ref, _results;
          _ref = data[name];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            site = _ref[_i];
            _results.push({
              title: site.title,
              url: site.url,
              datetime: site.datetime
            });
          }
          return _results;
        })();
        return callback(sites);
      });
    };

    Tag.prototype.fetchSharedTag = function(name, callback) {
      return this.localStore.get('sharedTags', function(data) {
        data.sharedTags || (data.sharedTags = {});
        return callback(data.sharedTags[name]);
      });
    };

    Tag.prototype.fetchSiteTags = function(url, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.localStore.get('tags', function(data) {
        var tags;
        tags = data.tags || [];
        return _this.localStore.get(tags, function(data) {
          var foundTags, site, sites, tag, _i, _len;
          foundTags = [];
          for (tag in data) {
            sites = data[tag];
            for (_i = 0, _len = sites.length; _i < _len; _i++) {
              site = sites[_i];
              if (site.url === url) {
                foundTags.push(tag);
              }
            }
          }
          return callback(foundTags);
        });
      });
    };

    Tag.prototype.shareTag = function(tag, url, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.localStore.get("sharedTags", function(data) {
        if (data.sharedTags == null) {
          data = {
            sharedTags: {}
          };
        }
        data.sharedTags[tag] = url;
        return _this.localStore.set(data, function() {
          return callback();
        });
      });
    };

    Tag.prototype.addSiteToTag = function(site, tag, callback) {
      var operations,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      operations = {
        tagCreated: false
      };
      this.localStore.get("tags", function(data) {
        if (data.tags == null) {
          data = {
            tags: []
          };
        }
        if (data.tags.indexOf(tag) === -1) {
          operations.tagCreated = true;
          data.tags.unshift(tag);
        }
        return _this.localStore.set(data, function() {
          return _this.localStore.get(tag, function(data) {
            data[tag] || (data[tag] = []);
            data[tag].push(site);
            return _this.localStore.set(data, function() {
              return callback(operations);
            });
          });
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype.addSitesToTag = function(sites, tag, callback) {
      var operations,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      operations = {
        tagCreated: false
      };
      this.localStore.get("tags", function(data) {
        if (data.tags == null) {
          data = {
            tags: []
          };
        }
        if (data.tags.indexOf(tag) === -1) {
          operations.tagCreated = true;
          data.tags.unshift(tag);
        }
        return _this.localStore.set(data, function() {
          return _this.localStore.get(tag, function(data) {
            var site, _i, _len;
            for (_i = 0, _len = sites.length; _i < _len; _i++) {
              site = sites[_i];
              data[tag] || (data[tag] = []);
              data[tag].push(site);
            }
            return _this.localStore.set(data, function() {
              return callback(operations);
            });
          });
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype["import"] = function(data, callback) {
      return this.localStore.set(data, callback);
    };

    Tag.prototype.clearAll = function() {
      return this.localStore.clear();
    };

    Tag.prototype.removeSiteFromTag = function(url, tag, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get(tag, function(data) {
        data[tag] || (data[tag] = []);
        data[tag] = _.reject(data[tag], function(site) {
          return url === site.url;
        });
        return _this.localStore.set(data, function() {
          return callback(data[tag]);
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype.removeSitesFromTag = function(urls, tag, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get(tag, function(data) {
        data[tag] || (data[tag] = []);
        data[tag] = _.reject(data[tag], function(site) {
          return _.find(urls, function(url) {
            return site.url === url;
          });
        });
        return _this.localStore.set(data, function() {
          return callback(data[tag]);
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype.removeTag = function(tag, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get('tags', function(data) {
        data.tags || (data.tags = []);
        data.tags = _.without(data.tags, tag);
        return _this.localStore.set(data, function() {
          return _this.localStore.remove(tag, function() {
            return callback();
          });
        });
      });
      return this.expireSharedTag(tag);
    };

    Tag.prototype.removeAllTags = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get('tags', function(data) {
        var tags;
        tags = data.tags || [];
        return _this.localStore.remove(tags, function() {
          return _this.localStore.set({
            tags: []
          }, function() {
            return callback();
          });
        });
      });
      return this.expireSharedTag();
    };

    Tag.prototype.renameTag = function(oldTag, newTag, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      this.localStore.get('tags', function(data) {
        var newTagExists;
        data.tags || (data.tags = []);
        if (data.tags.indexOf(newTag) !== -1) {
          newTagExists = true;
        }
        data.tags = _.without(data.tags, oldTag);
        if (newTagExists) {
          data.tags = _.without(data.tags, newTag);
        }
        data.tags.unshift(newTag);
        return _this.localStore.set(data, function() {
          return _this.localStore.get(oldTag, function(data) {
            var sites;
            sites = data[oldTag];
            if (newTagExists) {
              return _this.localStore.get(newTag, function(data) {
                return _this.localStore.remove(oldTag, function() {
                  var site, _i, _len;
                  for (_i = 0, _len = sites.length; _i < _len; _i++) {
                    site = sites[_i];
                    data[newTag].push(site);
                  }
                  return _this.localStore.set(data, function() {
                    return callback();
                  });
                });
              });
            } else {
              return _this.localStore.remove(oldTag, function() {
                data = {};
                data[newTag] = sites;
                return _this.localStore.set(data, function() {
                  return callback();
                });
              });
            }
          });
        });
      });
      return this.expireSharedTag(oldTag);
    };

    Tag.prototype.expireSharedTag = function(tag, callback) {
      var _this = this;
      if (tag == null) {
        tag = null;
      }
      if (callback == null) {
        callback = function() {};
      }
      return this.localStore.get('sharedTags', function(data) {
        data.sharedTags || (data.sharedTags = {});
        if (tag != null) {
          delete data.sharedTags[tag];
        } else {
          data.sharedTags = {};
        }
        return _this.localStore.set(data, function() {
          return callback();
        });
      });
    };

    return Tag;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var error;

  error = function(data, type) {
    return tagState.set({
      readOnly: true
    });
  };

  BH.Persistence.Remote = (function() {

    function Remote(authId, ajax) {
      this.authId = authId;
      this.ajax = ajax;
    }

    Remote.prototype.host = function() {
      return "http://" + apiHost;
    };

    Remote.prototype.updateAuthId = function(authId) {
      return this.authId = authId;
    };

    Remote.prototype.performRequest = function(options) {
      var config,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (!navigator.onLine) {
        return error();
      }
      if (!options.disableSyncingFeedback) {
        tagState.set({
          syncing: true
        });
      }
      config = {
        url: this.host() + options.path,
        type: options.type,
        contentType: 'application/json',
        dataType: options.dataType || 'text',
        error: function(data, type) {
          if (data.status === 403) {
            user.logout();
            return chrome.identity.getAuthToken(function(token) {
              return chrome.identity.removeCachedAuthToken({
                token: token
              }, function() {
                var authErrorModal;
                authErrorModal = new BH.Modals.AuthErrorModal();
                return authErrorModal.open();
              });
            });
          } else {
            error(data, type);
            if (options.error != null) {
              return options.error(data, type);
            }
          }
        },
        success: function(data) {
          tagState.set({
            readOnly: false
          });
          if (options.success != null) {
            return options.success(data);
          }
        },
        complete: function() {
          setTimeout(function() {
            return tagState.set({
              syncing: false
            });
          }, 1000);
          if (options.complete != null) {
            return options.complete();
          }
        }
      };
      if (options.authorization) {
        config.headers = {
          authorization: this.authId
        };
      }
      if (options.data != null) {
        config.data = JSON.stringify(options.data);
      }
      return this.ajax(config);
    };

    Remote.prototype.sitesHash = function(callback) {
      return this.performRequest({
        path: '/user/sites/hash',
        type: 'GET',
        dataType: 'json',
        authorization: true,
        disableSyncingFeedback: true,
        success: callback
      });
    };

    Remote.prototype.share = function(tagData, callbacks) {
      var params;
      params = {
        path: '/share',
        data: tagData,
        type: 'POST',
        dataType: 'json',
        success: callbacks.success,
        error: callbacks.error,
        disableSyncingFeedback: true,
        authorization: false
      };
      if (user.isLoggedIn()) {
        params.path = '/user/share';
        params.authorization = true;
      }
      return this.performRequest(params);
    };

    Remote.prototype.updateSite = function(site) {
      return this.performRequest({
        path: '/user/site',
        type: 'POST',
        data: site,
        authorization: true
      });
    };

    Remote.prototype.updateSites = function(sites, callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.performRequest({
        path: '/user/sites',
        type: 'POST',
        data: sites,
        success: callback,
        authorization: true
      });
    };

    Remote.prototype.getSites = function(callback) {
      return this.performRequest({
        path: '/user/sites',
        type: 'GET',
        dataType: 'json',
        success: callback,
        authorization: true
      });
    };

    Remote.prototype.renameTag = function(oldName, newName) {
      return this.performRequest({
        path: "/user/tags/" + (oldName.replace(/\s+/g, '-')) + "/rename",
        type: 'PUT',
        data: {
          name: newName
        },
        authorization: true
      });
    };

    Remote.prototype.deleteTag = function(name) {
      return this.performRequest({
        path: "/user/tags/" + (name.replace(/\s+/g, '-')),
        type: 'DELETE',
        authorization: true
      });
    };

    Remote.prototype.deleteSites = function(callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.performRequest({
        path: '/user/sites',
        type: 'DELETE',
        success: callback,
        authorization: true
      });
    };

    return Remote;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Modules.I18n = {
    t: function(key, replacements) {
      var keys, lookup, _i, _len;
      if (replacements == null) {
        replacements = [];
      }
      if (key instanceof Array) {
        keys = key;
        lookup = {};
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          lookup["i18n_" + key] = chrome.i18n.getMessage(key.toString());
        }
        return lookup;
      } else {
        return chrome.i18n.getMessage(key, replacements);
      }
    }
  };

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Modules.Url = {
    urlFor: function(key, id, opts) {
      var base, buildBase, route;
      base = 'chrome://history/';
      if (key == null) {
        return base;
      }
      buildBase = function(opts) {
        if (opts != null ? opts.absolute : void 0) {
          return base;
        } else {
          return '';
        }
      };
      route = (function() {
        switch (key) {
          case 'search':
            return "#search/" + id;
          case 'week':
            return "#weeks/" + id;
          case 'day':
            return "#days/" + id;
          case 'tag':
            return "#tags/" + id;
        }
      })();
      return "" + (buildBase(opts)) + route;
    }
  };

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Models.Site = (function(_super) {

    __extends(Site, _super);

    function Site() {
      return Site.__super__.constructor.apply(this, arguments);
    }

    Site.prototype.fetch = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return persistence.tag().fetchSiteTags(this.get('url'), function(tags) {
        _this.set({
          tags: tags
        });
        _this.trigger('reset:tags');
        return callback();
      });
    };

    Site.prototype.tags = function() {
      return this.get('tags');
    };

    Site.prototype.addTag = function(tag, callback) {
      var newTags, site,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      tag = tag.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      if (tag.length === 0 || tag.match(/[\"\'\~\,\.\|\(\)\{\}\[\]\;\:\<\>\^\*\%\^]/) || this.get('tags').indexOf(tag) !== -1) {
        callback(false, null);
        return;
      }
      newTags = _.clone(this.get('tags'));
      newTags.push(tag);
      this.set({
        tags: newTags,
        datetime: new Date().getTime()
      });
      site = {
        url: this.get('url'),
        title: this.get('title'),
        datetime: this.get('datetime')
      };
      return persistence.tag().addSiteToTag(site, tag, function(operations) {
        chrome.runtime.sendMessage({
          action: 'calculate hash'
        });
        _this.sync();
        return callback(true, operations);
      });
    };

    Site.prototype.sync = function() {
      var _this = this;
      if (user.isLoggedIn()) {
        return BH.Lib.ImageData.base64("chrome://favicon/" + (this.get('url')), function(data) {
          return persistence.remote().updateSite({
            url: _this.get('url'),
            title: _this.get('title'),
            datetime: _this.get('datetime'),
            tags: _this.get('tags'),
            image: data
          });
        });
      }
    };

    Site.prototype.removeTag = function(tag) {
      var newTags,
        _this = this;
      if (this.get('tags').indexOf(tag) === -1) {
        return false;
      }
      newTags = _.clone(this.get('tags'));
      this.set({
        tags: _.without(newTags, tag),
        datetime: new Date().getTime()
      });
      return persistence.tag().removeSiteFromTag(this.get('url'), tag, function() {
        chrome.runtime.sendMessage({
          action: 'calculate hash'
        });
        return _this.sync();
      });
    };

    return Site;

  })(Backbone.Model);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Models.Tag = (function(_super) {

    __extends(Tag, _super);

    function Tag() {
      return Tag.__super__.constructor.apply(this, arguments);
    }

    Tag.prototype.initialize = function() {
      return this.on('sync', this.sync);
    };

    Tag.prototype.validate = function(attrs, options) {
      var name;
      name = attrs.name.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      if (name.length === 0) {
        return "tag is empty";
      }
      if (name.match(/[\"\'\~\,\.\|\(\)\{\}\[\]\;\:\<\>\^\*\%\^]/)) {
        return "tag contains special characters";
      }
    };

    Tag.prototype.fetch = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return persistence.tag().fetchTagSites(this.get('name'), function(sites) {
        return persistence.tag().fetchSharedTag(_this.get('name'), function(url) {
          _this.set({
            sites: sites,
            url: url
          });
          return callback();
        });
      });
    };

    Tag.prototype.destroy = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return persistence.tag().removeTag(this.get('name'), function() {
        _this.trigger('sync', {
          operation: 'destroy'
        });
        _this.set({
          sites: []
        });
        chrome.runtime.sendMessage({
          action: 'calculate hash'
        });
        return callback();
      });
    };

    Tag.prototype.removeSite = function(url, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return persistence.tag().removeSiteFromTag(url, this.get('name'), function(sites) {
        _this.trigger('sync', {
          operation: 'modify',
          site: _.where(_this.get('sites'), {
            url: url
          })[0]
        });
        _this.set({
          sites: sites
        });
        chrome.runtime.sendMessage({
          action: 'calculate hash'
        });
        return callback();
      });
    };

    Tag.prototype.renameTag = function(name, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return persistence.tag().renameTag(this.get('name'), name, function() {
        _this.trigger('sync', {
          operation: 'rename',
          newName: name,
          oldName: _this.get('name')
        });
        _this.set({
          name: name
        });
        chrome.runtime.sendMessage({
          action: 'calculate hash'
        });
        return callback();
      });
    };

    Tag.prototype.share = function(callbacks) {
      var index, json,
        _this = this;
      index = 1;
      json = this.toJSON();
      return _.each(json.sites, function(site, i) {
        return BH.Lib.ImageData.base64("chrome://favicon/" + site.url, function(data) {
          json.sites[i].image = data;
          if (index !== json.sites.length) {
            return index++;
          } else {
            return persistence.remote().share(json, {
              success: function(data) {
                persistence.tag().shareTag(_this.get('name'), data.url);
                return callbacks.success(data);
              },
              error: function() {
                return callbacks.error();
              }
            });
          }
        });
      });
    };

    Tag.prototype.sync = function(options) {
      var site;
      if (user.isLoggedIn()) {
        switch (options.operation) {
          case 'destroy':
            return persistence.remote().deleteTag(this.get('name'));
          case 'rename':
            return persistence.remote().renameTag(options.oldName, options.newName);
          case 'modify':
            site = options.site;
            return persistence.tag().fetchSiteTags(site.url, function(tags) {
              site.tags = tags;
              return persistence.remote().updateSite(site);
            });
        }
      }
    };

    return Tag;

  })(Backbone.Model);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Models.User = (function(_super) {

    __extends(User, _super);

    function User() {
      return User.__super__.constructor.apply(this, arguments);
    }

    User.prototype.storeName = 'user';

    User.prototype.initialize = function() {
      this.chromeAPI = chrome;
      return this.loggedIn = false;
    };

    User.prototype.fetch = function() {
      var _this = this;
      return this.chromeAPI.storage.sync.get('user', function(data) {
        var _ref;
        if (((_ref = data.user) != null ? _ref.authId : void 0) != null) {
          return _this.login(data.user);
        }
      });
    };

    User.prototype.save = function() {
      return this.chromeAPI.storage.sync.set({
        user: this.toJSON()
      });
    };

    User.prototype.login = function(data) {
      this.set(data);
      this.save();
      this.trigger('login');
      return this.loggedIn = true;
    };

    User.prototype.logout = function() {
      this.clear({
        silent: true
      });
      this.save();
      this.trigger('logout');
      return this.loggedIn = false;
    };

    User.prototype.isLoggedIn = function() {
      return this.loggedIn;
    };

    return User;

  })(Backbone.Model);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Models.Settings = (function(_super) {

    __extends(Settings, _super);

    function Settings() {
      return Settings.__super__.constructor.apply(this, arguments);
    }

    Settings.prototype.storeName = 'settings';

    Settings.prototype.defaults = function() {
      return {
        timeGrouping: 15,
        domainGrouping: true,
        searchByDomain: true,
        searchBySelection: true,
        openLocation: 'last_visit',
        startingWeekDay: 'Monday',
        weekDayOrder: 'ascending'
      };
    };

    return Settings;

  })(Backbone.Model);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Models.State = (function(_super) {

    __extends(State, _super);

    function State() {
      return State.__super__.constructor.apply(this, arguments);
    }

    State.include(BH.Modules.I18n);

    State.include(BH.Modules.Url);

    State.prototype.storeName = 'state';

    State.prototype.initialize = function(attrs, options) {
      var weekId;
      this.chromeAPI = chrome;
      this.settings = options.settings;
      if (typeof moment !== "undefined" && moment !== null) {
        weekId = this.startingWeekDate().id();
        return this.set({
          route: this.urlFor('week', weekId)
        });
      }
    };

    State.prototype.updateRoute = function() {
      var route, weekId;
      if (this.settings.get('openLocation') === 'current_day') {
        route = this.urlFor('day', moment(new Date()).id());
      } else if (this.settings.get('openLocation') === 'current_week') {
        weekId = this.startingWeekDate().id();
        route = this.urlFor('week', weekId);
      }
      if (route != null) {
        this.set({
          route: route
        });
      }
      return this.save();
    };

    State.prototype.startingWeekDate = function() {
      return moment(new Date()).past(this.settings.get('startingWeekDay'), 0);
    };

    return State;

  })(Backbone.Model);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Collections.Tags = (function(_super) {

    __extends(Tags, _super);

    function Tags() {
      return Tags.__super__.constructor.apply(this, arguments);
    }

    Tags.prototype.model = BH.Models.Tag;

    Tags.prototype.initialize = function() {
      if (user.isLoggedIn()) {
        return this.on('sync', this.sync);
      }
    };

    Tags.prototype.fetch = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return persistence.tag().fetchTags(function(tags, compiledTags) {
        _this.tagOrder = tags;
        _this.reset(compiledTags);
        return callback();
      });
    };

    Tags.prototype.destroy = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return persistence.tag().removeAllTags(function() {
        chrome.runtime.sendMessage({
          action: 'calculate hash'
        });
        callback();
        return _this.trigger('sync', {
          operation: 'destroy'
        });
      });
    };

    Tags.prototype.sync = function(options) {
      switch (options.operations) {
        case 'destroy':
          return persistence.remote().deleteSites();
      }
    };

    return Tags;

  })(Backbone.Collection);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Views.MainView = (function(_super) {

    __extends(MainView, _super);

    function MainView() {
      return MainView.__super__.constructor.apply(this, arguments);
    }

    MainView.prototype.select = function() {
      var cleanTitle, element,
        _this = this;
      $('.mainview > *').removeClass('selected');
      $('.mainview > *').css({
        display: 'block'
      });
      setTimeout(function() {
        _this.$el.addClass('selected');
        return $('.mainview > *:not(.selected)').css({
          display: 'none'
        });
      }, 0);
      if (this.pageTitle) {
        element = $('<div/>');
        cleanTitle = $(element).html(this.pageTitle()).text();
        document.title = "" + cleanTitle + " - Better History";
      }
      this.trigger('selected');
      return this;
    };

    MainView.prototype.onSearchTyped = function(ev) {
      var term;
      term = this.trimedSearchTerm();
      if (ev.keyCode === 13 && term !== '') {
        return router.navigate('search/' + term, true);
      }
    };

    MainView.prototype.onSearchBlurred = function() {
      return this.$('.search').val(this.trimedSearchTerm());
    };

    MainView.prototype.trimedSearchTerm = function() {
      return $.trim(this.$('.search').val());
    };

    MainView.prototype.assignTabIndices = function(selector) {
      $('*').removeAttr('tabindex');
      this.$('input.search').attr('tabindex', 1);
      this.$(selector).each(function(i) {
        return $(this).attr('tabindex', i + 2);
      });
      return this.$('.search').focus();
    };

    return MainView;

  })(Backbone.View);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Views.TaggingView = (function(_super) {

    __extends(TaggingView, _super);

    function TaggingView() {
      return TaggingView.__super__.constructor.apply(this, arguments);
    }

    TaggingView.include(BH.Modules.I18n);

    TaggingView.include(BH.Modules.Url);

    TaggingView.prototype.template = BH.Templates['tagging'];

    TaggingView.prototype.className = 'tagging_view';

    TaggingView.prototype.events = {
      'click #view_history': 'viewHistoryClicked',
      'click #explore_tags': 'exploreTagsClicked',
      'click #search_domain': 'searchDomainClicked',
      'click #tag_details': 'tagDetailsClicked',
      'click .dismiss_instructions': 'dismissInstructionsClicked',
      'click #add_tag': 'addTagClicked'
    };

    TaggingView.prototype.initialize = function() {
      this.chromeAPI = chrome;
      this.tracker = this.options.tracker;
      return this.model.on('reset:tags', this.renderTags, this);
    };

    TaggingView.prototype.render = function() {
      var _this = this;
      return this.getShortcut(function(commands) {
        var html, presenter, properties;
        presenter = new BH.Presenters.SitePresenter(_this.model);
        properties = _.extend(presenter.site(), _this.getI18nValues());
        properties.i18n_search_domain_history_link = _this.t('search_domain_history_link', [properties.domain]);
        if (commands != null) {
          properties.shortcut = _.where(commands, {
            name: '_execute_browser_action'
          })[0].shortcut;
        }
        if (user.isLoggedIn()) {
          properties.loggedIn = true;
        }
        _.extend(properties, tagState.toJSON());
        html = Mustache.to_html(_this.template, properties);
        _this.tracker.popupVisible();
        _this.$el.html(html);
        _this.$('.links a').each(function(i) {
          return $(this).attr('tabindex', i);
        });
        setTimeout(function() {
          return _this.$('#tag_name').focus();
        }, 0);
        return _this;
      });
    };

    TaggingView.prototype.getShortcut = function(callback) {
      var _ref,
        _this = this;
      if (((_ref = this.chromeAPI.commands) != null ? _ref.getAll : void 0) != null) {
        return this.chromeAPI.commands.getAll(function(commands) {
          return callback(commands);
        });
      } else {
        return callback();
      }
    };

    TaggingView.prototype.renderTags = function() {
      if (this.autocompleteTagsView) {
        this.autocompleteTagsView.remove();
      }
      this.autocompleteTagsView = new BH.Views.AutocompleteTagsView({
        model: this.model,
        collection: this.collection,
        tracker: this.tracker
      });
      this.$('.autocomplete').html(this.autocompleteTagsView.render().el);
      return this.collection.fetch();
    };

    TaggingView.prototype.viewHistoryClicked = function(ev) {
      ev.preventDefault();
      this.tracker.viewAllHistoryPopupClick();
      return chrome.tabs.create({
        url: $(ev.currentTarget).attr('href')
      });
    };

    TaggingView.prototype.exploreTagsClicked = function(ev) {
      ev.preventDefault();
      this.tracker.exploreTagsPopupClick();
      return chrome.tabs.create({
        url: $(ev.currentTarget).attr('href')
      });
    };

    TaggingView.prototype.searchDomainClicked = function(ev) {
      ev.preventDefault();
      this.tracker.searchByDomainPopupClick();
      return chrome.tabs.create({
        url: $(ev.currentTarget).attr('href')
      });
    };

    TaggingView.prototype.tagDetailsClicked = function(ev) {
      ev.preventDefault();
      this.tracker.tagDetailsPopupClick();
      return chrome.tabs.create({
        url: $(ev.currentTarget).attr('href')
      });
    };

    TaggingView.prototype.addTagClicked = function(ev) {
      var $tagName, parent, tag;
      ev.preventDefault();
      $tagName = this.$('#tag_name');
      tag = $tagName.val();
      $tagName.val('');
      this.tracker.addTagPopup();
      if (this.model.addTag(tag) === false) {
        if (parent = $("[data-tag='" + tag + "']").parents('li')) {
          parent.addClass('glow');
          return setTimeout(function() {
            return parent.removeClass('glow');
          }, 1000);
        }
      }
    };

    TaggingView.prototype.dismissInstructionsClicked = function(ev) {
      ev.preventDefault();
      syncStore.set({
        tagInstructionsDismissed: true
      });
      return $('.about_tags').hide();
    };

    TaggingView.prototype.getI18nValues = function() {
      var properties;
      properties = this.t(['view_all_history_link', 'explore_tags_link']);
      properties.i18n_about_tags_for_popup = this.t('about_tags_for_popup', ['<span class="new">', '</span>', '<a id="tag_details" href="chrome://history/#tags">', '</a>']);
      return properties;
    };

    return TaggingView;

  })(BH.Views.MainView);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Views.ActiveTagsView = (function(_super) {

    __extends(ActiveTagsView, _super);

    function ActiveTagsView() {
      return ActiveTagsView.__super__.constructor.apply(this, arguments);
    }

    ActiveTagsView.include(BH.Modules.I18n);

    ActiveTagsView.prototype.template = BH.Templates['active_tags'];

    ActiveTagsView.prototype.className = 'active_tags_view';

    ActiveTagsView.prototype.events = {
      'click .delete': 'deleteTagClicked',
      'click .tag': 'tagClicked'
    };

    ActiveTagsView.prototype.initialize = function() {
      this.chromeAPI = chrome;
      this.tracker = this.options.tracker;
      this.editable = this.options.editable || false;
      return this.inBrowserAction = this.options.inBrowserAction || false;
    };

    ActiveTagsView.prototype.render = function() {
      var html, properties;
      properties = {
        tags: this.model.tags(),
        editable: this.editable
      };
      html = Mustache.to_html(this.template, properties);
      this.$el.html(html);
      return this;
    };

    ActiveTagsView.prototype.deleteTagClicked = function(ev) {
      var tag;
      ev.preventDefault();
      tag = $(ev.currentTarget).data('tag');
      this.model.removeTag(tag);
      return this.tracker.siteUntagged();
    };

    ActiveTagsView.prototype.tagClicked = function(ev) {
      var tag;
      if (this.inBrowserAction != null) {
        ev.preventDefault();
        tag = $(ev.currentTarget).data('tag');
        return this.chromeAPI.tabs.create({
          url: "chrome://history#tags/" + tag
        });
      }
    };

    return ActiveTagsView;

  })(BH.Views.MainView);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Views.AutocompleteTagsView = (function(_super) {

    __extends(AutocompleteTagsView, _super);

    function AutocompleteTagsView() {
      return AutocompleteTagsView.__super__.constructor.apply(this, arguments);
    }

    AutocompleteTagsView.include(BH.Modules.I18n);

    AutocompleteTagsView.prototype.template = BH.Templates['autocomplete_tags'];

    AutocompleteTagsView.prototype.events = {
      'click .delete': 'deleteTagClicked',
      'click .tag': 'tagClicked',
      'keyup input.new_tag': 'newTagChanged'
    };

    AutocompleteTagsView.prototype.initialize = function() {
      this.chromeAPI = chrome;
      this.tracker = this.options.tracker;
      this.collection.on('reset', this.render, this);
      this.model.on('change:tags', this.renderActiveTags, this);
      return tagState.on('change:syncing', this.onSyncingChanged, this);
    };

    AutocompleteTagsView.prototype.render = function() {
      var html, properties;
      properties = _.extend(this.getI18nValues(), {
        tags: this.model.tags()
      });
      html = Mustache.to_html(this.template, properties);
      this.$el.html(html);
      this.renderSuggestionsView();
      this.renderActiveTags();
      setTimeout(function() {
        return this.$('input.new_tag').focus();
      }, 0);
      return this;
    };

    AutocompleteTagsView.prototype.renderSuggestionsView = function() {
      var _this = this;
      this.suggestionsView = new BH.Views.SuggestionsView({
        collection: new Backbone.Collection(this.collection.toJSON()),
        disqualifiedTags: this.model.tags()
      });
      $('.suggestions').html(this.suggestionsView.render().el);
      return this.suggestionsView.on('click:tag', function(tag) {
        return _this.attemptToAddTag(tag);
      }, this);
    };

    AutocompleteTagsView.prototype.renderActiveTags = function() {
      var activeTagsView;
      activeTagsView = new BH.Views.ActiveTagsView({
        model: this.model,
        editable: true,
        tracker: this.tracker
      });
      return this.$('.active_tags').html(activeTagsView.render().el);
    };

    AutocompleteTagsView.prototype.newTagChanged = function(ev) {
      var $input, $tag, $tags, enteredTag, tag;
      ev.preventDefault();
      this.previousEnteredTag || (this.previousEnteredTag = '');
      $input = $(ev.currentTarget);
      enteredTag = $input.val();
      if (ev.keyCode === 8 && enteredTag.length === 0 && this.previousEnteredTag.length === 0) {
        $tags = $('ul.tags');
        if ($tags.length > 0) {
          $tag = $tags.find('li:not(.input)').last();
          if ($tag) {
            tag = $tag.find('a.tag').data('tag');
            this.model.removeTag(tag);
            this.tracker.siteUntagged();
            this.suggestionsView.requalifyTag(tag);
            return $tag.remove();
          }
        }
      } else {
        if (enteredTag.length <= 1) {
          return this.suggestionsView.hide();
        } else {
          this.suggestionsView.show();
          if (ev.keyCode === 40) {
            this.suggestionsView.moveDown();
            $input.val(this.suggestionsView.selectedTag());
            return this.previousEnteredTag = enteredTag;
          } else if (ev.keyCode === 38) {
            this.suggestionsView.moveUp();
            $input.val(this.suggestionsView.selectedTag());
            return this.previousEnteredTag = enteredTag;
          } else if (ev.keyCode === 13) {
            tag = this.suggestionsView.selectedTag() || enteredTag;
            return this.attemptToAddTag(tag);
          } else {
            this.suggestionsView.filterBy(enteredTag);
            this.previousEnteredTag = enteredTag;
            return this.$('.new_tag').removeClass('error');
          }
        }
      }
    };

    AutocompleteTagsView.prototype.onSyncingChanged = function() {
      if (tagState.get('syncing') === true) {
        return $('body').addClass('syncing');
      } else {
        return $('body').removeClass('syncing');
      }
    };

    AutocompleteTagsView.prototype.attemptToAddTag = function(tag) {
      var _this = this;
      return this.model.addTag(tag, function(result, operations) {
        var $usedTag;
        if (operations == null) {
          operations = {};
        }
        if (result) {
          _this.suggestionsView.disqualifyTag(tag);
          _this.tracker.siteTagged();
          if (operations.tagCreated) {
            _this.tracker.tagAdded();
          }
        } else {
          $usedTag = _this.$(".active_tags [data-tag='" + tag + "']");
          if ($usedTag.length > 0) {
            $usedTag.addClass('glow');
            setTimeout((function() {
              return $usedTag.removeClass('glow');
            }), 1000);
          } else {
            _this.$('.new_tag').addClass('error');
          }
        }
        if (!_this.$('.new_tag').hasClass('error')) {
          _this.$('.new_tag').val('');
          _this.previousEnteredTag = '';
        }
        return _this.suggestionsView.hide();
      });
    };

    AutocompleteTagsView.prototype.getI18nValues = function() {
      return this.t(['add_a_tag_placeholder']);
    };

    return AutocompleteTagsView;

  })(Backbone.View);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BH.Views.SuggestionsView = (function(_super) {

    __extends(SuggestionsView, _super);

    function SuggestionsView() {
      return SuggestionsView.__super__.constructor.apply(this, arguments);
    }

    SuggestionsView.prototype.template = BH.Templates['suggestions'];

    SuggestionsView.prototype.className = 'suggestions suggestions_view';

    SuggestionsView.prototype.events = {
      'click li': 'onTagClicked'
    };

    SuggestionsView.prototype.initialize = function() {
      return this.disqualifiedTags = this.options.disqualifiedTags || [];
    };

    SuggestionsView.prototype.render = function() {
      var html, tags;
      tags = _.difference(this.collection.pluck('name'), this.disqualifiedTags);
      html = Mustache.to_html(this.template, {
        tags: tags
      });
      this.$el.hide();
      this.$el.html(html);
      return this;
    };

    SuggestionsView.prototype.onTagClicked = function(ev) {
      return this.trigger('click:tag', $(ev.currentTarget).data('tag'));
    };

    SuggestionsView.prototype.show = function() {
      return this.$el.show();
    };

    SuggestionsView.prototype.hide = function() {
      return this.$el.hide();
    };

    SuggestionsView.prototype.moveDown = function() {
      var $activeTags, $selected, index;
      $activeTags = this.$('li.active');
      $selected = this.$('.selected');
      if ($selected.length > 0) {
        index = $activeTags.indexOf($selected[0]) + 1;
        if (index !== $activeTags.length) {
          $selected.removeClass('selected');
          $selected = $activeTags.eq(index);
          return $selected.addClass('selected');
        }
      } else {
        $selected = $activeTags.eq(0);
        return $selected.addClass('selected');
      }
    };

    SuggestionsView.prototype.moveUp = function() {
      var $activeTags, $selected, index;
      $activeTags = this.$('li.active');
      $selected = this.$('.selected');
      if ($selected.length > 0) {
        index = $activeTags.indexOf($selected[0]);
        if (index !== 0) {
          $selected.removeClass('selected');
          $selected = $activeTags.eq(index - 1);
          return $selected.addClass('selected');
        }
      }
    };

    SuggestionsView.prototype.selectedTag = function() {
      var $selected;
      $selected = this.$('.selected');
      return $selected.data('tag');
    };

    SuggestionsView.prototype.filterBy = function(text) {
      var hiddenTags;
      hiddenTags = _.intersection(this.disqualifiedTags, this.collection.pluck('name')).length;
      this.$('li').each(function() {
        if ($(this).data('tag').match(text)) {
          return $(this).addClass('active');
        } else {
          hiddenTags += 1;
          return $(this).removeClass('active');
        }
      });
      if (hiddenTags === this.collection.length) {
        return this.hide();
      } else {
        return this.show();
      }
    };

    SuggestionsView.prototype.disqualifyTag = function(tag) {
      this.disqualifiedTags.push(tag);
      return this.render();
    };

    SuggestionsView.prototype.requalifyTag = function(tag) {
      this.disqualifiedTags = _.without(this.disqualifiedTags, tag);
      return this.render();
    };

    return SuggestionsView;

  })(Backbone.View);

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Presenters.SitePresenter = (function() {

    function SitePresenter(model) {
      this.model = model;
    }

    SitePresenter.prototype.site = function() {
      var domain, match, out;
      match = this.model.get('url').match(/\/\/(.*?)\//);
      domain = match === null ? null : match[1];
      if (domain) {
        domain = domain.replace('www.', '');
      }
      out = this.model.toJSON();
      out.domain = domain;
      return out;
    };

    return SitePresenter;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Presenters.TagsPresenter = (function() {

    function TagsPresenter(collection) {
      this.collection = collection;
    }

    TagsPresenter.prototype.tagsSummary = function() {
      var model, orderedSites, out, tag, _i, _len, _ref;
      out = [];
      _ref = this.collection.tagOrder;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tag = _ref[_i];
        model = this.collection.findWhere({
          name: tag
        });
        if (model != null) {
          orderedSites = model.get('sites').sort(function(a, b) {
            return b.datetime - a.datetime;
          });
          out.push({
            name: model.get('name'),
            count: model.get('sites').length,
            sites: orderedSites.slice(0, 10)
          });
        }
      }
      return out;
    };

    TagsPresenter.prototype.selectedAndUnselectedTagsforSites = function(sites) {
      var commonTags, model, result, site, tag, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      _ref = this.collection.tagOrder;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tag = _ref[_i];
        model = this.collection.findWhere({
          name: tag
        });
        for (_j = 0, _len1 = sites.length; _j < _len1; _j++) {
          site = sites[_j];
          result = _.find(model.get('sites'), function(taggedSite) {
            return taggedSite.url === site.url;
          });
          if (result != null) {
            if (!site.tags) {
              site.tags = [];
            }
            site.tags.push(model.get('name'));
          }
        }
      }
      commonTags = _.intersection.apply(_, _.pluck(sites, 'tags'));
      _ref1 = this.collection.tagOrder;
      _results = [];
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        tag = _ref1[_k];
        model = this.collection.findWhere({
          name: tag
        });
        _results.push({
          name: model.get('name'),
          tagged: commonTags.indexOf(model.get('name')) !== -1
        });
      }
      return _results;
    };

    return TagsPresenter;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Init.TagFeature = (function() {

    function TagFeature(options) {
      this.syncStore = options.syncStore;
    }

    TagFeature.prototype.announce = function(callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.syncStore.get('tagInstructionsDismissed', function(data) {
        var tagInstructionsDismissed;
        tagInstructionsDismissed = data.tagInstructionsDismissed || false;
        if (!tagInstructionsDismissed) {
          return callback();
        }
      });
    };

    TagFeature.prototype.prepopulate = function(callback) {
      var _this = this;
      return this.syncStore.get('tagInstructionsDismissed', function(data) {
        var tagInstructionsDismissed;
        tagInstructionsDismissed = data.tagInstructionsDismissed || false;
        return persistence.tag().fetchTags(function(tags) {
          if (!tagInstructionsDismissed && tags.length === 0) {
            return callback();
          }
        });
      });
    };

    return TagFeature;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {

  BH.Init.Persistence = (function() {

    function Persistence(config) {
      this.config = config != null ? config : {};
    }

    Persistence.prototype.tag = function() {
      if (this.config.localStore == null) {
        throw "localStore requied";
      }
      return this.tagPersistence || (this.tagPersistence = new BH.Persistence.Tag({
        localStore: this.config.localStore
      }));
    };

    Persistence.prototype.remote = function(authId) {
      if (this.config.ajax == null) {
        throw "Ajax requied";
      }
      if (this.config.state == null) {
        throw "State required";
      }
      authId = authId || (typeof user !== "undefined" && user !== null ? user.get('authId') : void 0);
      this.remotePersistence || (this.remotePersistence = new BH.Persistence.Remote(authId, this.config.ajax, this.config.state));
      if (authId != null) {
        this.remotePersistence.updateAuthId(authId);
      }
      return this.remotePersistence;
    };

    return Persistence;

  })();

}).call(this);



// Generated by CoffeeScript 1.6.1
(function() {
  var analyticsTracker, errorTracker, load;

  window.apiHost = 'api.better-history.com';

  window.siteHost = 'www.better-history.com';

  window.env = 'prod';

  if (env === 'prod') {
    errorTracker = new BH.Trackers.ErrorTracker(Honeybadger);
  }

  analyticsTracker = new BH.Trackers.AnalyticsTracker();

  load = function() {
    var settings,
      _this = this;
    window.syncStore = new BH.Chrome.SyncStore({
      chrome: chrome,
      tracker: analyticsTracker
    });
    window.user = new BH.Models.User({});
    window.user.fetch();
    window.user.on('change', function() {
      if (this.get('authId')) {
        return this.trigger('login');
      }
    });
    window.user.on('login', function() {
      var syncer;
      syncer = new BH.Lib.Syncer();
      return syncer.updateIfNeeded();
    });
    window.tagState = new Backbone.Model({
      readOnly: false,
      syncing: false
    });
    settings = new BH.Models.Settings({});
    window.state = new BH.Models.State({}, {
      settings: settings
    });
    window.persistence = new BH.Init.Persistence({
      localStore: new BH.Chrome.LocalStore({
        chrome: chrome,
        tracker: analyticsTracker
      }),
      syncStore: new BH.Chrome.SyncStore({
        chrome: chrome,
        tracker: analyticsTracker
      }),
      ajax: $.ajax,
      state: state
    });
    return chrome.tabs.query({
      currentWindow: true,
      active: true
    }, function(tabs) {
      var attrs, site, tab, tagFeature, taggingView, tags;
      tab = tabs[0] || {};
      attrs = {
        title: tab.title,
        url: tab.url
      };
      site = new BH.Models.Site(attrs);
      tags = new BH.Collections.Tags([]);
      taggingView = new BH.Views.TaggingView({
        el: $('.app'),
        model: site,
        collection: tags,
        tracker: analyticsTracker
      });
      taggingView.render();
      if (!tagState.get('readOnly')) {
        site.fetch();
      }
      tagFeature = new BH.Init.TagFeature({
        syncStore: syncStore
      });
      return tagFeature.announce(function() {
        return $('body').addClass('new_tags');
      });
    });
  };

  if (env === 'prod') {
    try {
      load();
    } catch (e) {
      errorTracker.report(e);
    }
  } else {
    load();
  }

}).call(this);



